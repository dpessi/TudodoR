plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 5) # controla a animacao
p
anim_save('evolucao_convid.gif')
meu.plot <- p +
theme_light(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(.2,1.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 5) # controla a animacao
animate(plot = meu.plot,duration = 12, fps = 12) # controla a animacao
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
p <- ggplot(dados) +
geom_bar(aes(y = confirmados,  x = rank,
group = cidade,colour = cidade, fill = cidade),
alpha = 0.75, stat = "identity",width =.6 )+
coord_flip(clip = "off", expand = FALSE)+ # eixo x torna-se y e y torna-se x
geom_image(image=paste0('ufac_.png'),
aes(x=7,y=0.75*max(confirmados)),
size=.2)+
geom_text(aes(y = 0, x= rank,label = paste(cidade, " ")),
size=5.0,vjust = 0.2, hjust = 1)+ # rotulo do eixo x
geom_text(aes(y=confirmados,x= rank,
label = paste(" ",confirmados), hjust=0),size=4.5)+ # rotulo dos dados
scale_x_reverse()
p
ultimo.dia.ok <- paste0(day(ultimo.dia)," de ",
month(ultimo.dia,label = TRUE,abbr = FALSE),
" de ",year(ultimo.dia))
meu.plot <- p +
theme_light(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(.2,1.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
meu.plot <- p +
theme_minimal(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(.2,1.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
meu.plot <- p +
theme_minimal(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(.2,1.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 2.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
meu.plot <- p +
theme_minimal(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(2,1.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
meu.plot <- p +
theme_minimal(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(5,1.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
p
meu.plot <- p +
theme_minimal(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(.2,3.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
p <- ggplot(dados) +
geom_bar(aes(y = confirmados,  x = rank,
group = cidade,colour = cidade, fill = cidade),
alpha = 0.75, stat = "identity",width =.6 )+
coord_flip(clip = "off", expand = FALSE)+ # eixo x torna-se y e y torna-se x
geom_image(image=paste0('ufac_.png'),
aes(x=7,y=0.75*max(confirmados)),
size=.2)+
geom_text(aes(y = 0, x= rank,label = paste(cidade, " ")),
size=2.0,vjust = 0.2, hjust = 1)+ # rotulo do eixo x
geom_text(aes(y=confirmados,x= rank,
label = paste(" ",confirmados), hjust=0),size=4.5)+ # rotulo dos dados
scale_x_reverse()
ultimo.dia.ok <- paste0(day(ultimo.dia)," de ",
month(ultimo.dia,label = TRUE,abbr = FALSE),
" de ",year(ultimo.dia))
meu.plot <- p +
theme_minimal(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(.2,3.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
p <- ggplot(dados) +
geom_bar(aes(y = confirmados,  x = rank,
group = cidade,colour = cidade, fill = cidade),
alpha = 0.75, stat = "identity",width =.6 )+
coord_flip(clip = "off", expand = FALSE)+ # eixo x torna-se y e y torna-se x
geom_image(image=paste0('ufac_.png'),
aes(x=7,y=0.75*max(confirmados)),
size=.2)+
geom_text(aes(y = 0, x= rank,label = paste(cidade, " ")),
size=4.0,vjust = 0.2, hjust = 1)+ # rotulo do eixo x
geom_text(aes(y=confirmados,x= rank,
label = paste(" ",confirmados), hjust=0),size=4.5)+ # rotulo dos dados
scale_x_reverse()
ultimo.dia.ok <- paste0(day(ultimo.dia)," de ",
month(ultimo.dia,label = TRUE,abbr = FALSE),
" de ",year(ultimo.dia))
meu.plot <- p +
theme_minimal(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(.2,3.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
animate(plot = meu.plot,duration = 12, fps = 2) # controla a animacao
animate(plot = meu.plot,duration = 12, fps = 8) # controla a animacao
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
dados <- read.csv2(paste0("covid19-acre_2004.csv")) %>%
mutate(data=ymd(data)) %>%
group_by(day(data))%>% # agrupando os dados por dia
# fazendo um ranking ao contrario
# multiplica-se o resultado por 1 para que nao
# exista numeros inteiros durante a animacao
mutate(rank = min_rank(-confirmados)*1) %>%
ungroup() %>% #desagrupando
filter(rank<=7) # selecionando os 10 Estados c/ maior # de casos
ultimo.dia <- dados %>%
filter(cidade=="Acre") %>%
pull(data) %>%
last() %>%
as.character()
p <- ggplot(dados) +
geom_bar(aes(y = confirmados,  x = rank,
group = cidade,colour = cidade, fill = cidade),
alpha = 0.75, stat = "identity",width =.6 )+
coord_flip(clip = "off", expand = FALSE)+ # eixo x torna-se y e y torna-se x
geom_image(image=paste0('ufac_.png'),
aes(x=7,y=0.75*max(confirmados)),
size=.2)+
geom_text(aes(y = 0, x= rank,label = paste(cidade, " ")),
size=4.0,vjust = 0.2, hjust = 1)+ # rotulo do eixo x
geom_text(aes(y=confirmados,x= rank,
label = paste(" ",confirmados), hjust=0),size=4.5)+ # rotulo dos dados
scale_x_reverse()
ultimo.dia.ok <- paste0(day(ultimo.dia)," de ",
month(ultimo.dia,label = TRUE,abbr = FALSE),
" de ",year(ultimo.dia))
meu.plot <- p +
theme_minimal(16) +
labs(title ="Evolução dos Casos de Covid-19",
y = NULL,
x = NULL,
colour=NULL,
fill=NULL)+
theme(axis.ticks.y = element_blank(),
axis.text.y  = element_blank(),
axis.text.x  = element_blank(),
panel.background  = element_blank(),
panel.grid = element_blank(),
plot.margin  = unit(c(.2,3.5,0,2), "cm"),
plot.background = element_blank(),
plot.title = element_text(size = 17,hjust = .3),
plot.subtitle = element_text(size = 12,hjust = .3),
legend.position = "top",
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_blank())+
geom_text(aes(y = 0.7*max(confirmados),
x =9.8, label =paste0(day(data)," de ",
month(data,label = TRUE,abbr = FALSE),
" de ",year(data))),
size = 9, col = "#828285")+
guides(fill = guide_legend(override.aes = list(color = NULL,
size=3.2)))+
transition_time(data)+ # aqui acontece a animacao
ease_aes('cubic-in-out')
animate(plot = meu.plot,duration = 12, fps = 4) # controla a animacao
animate(plot = meu.plot,duration = 12, fps = 10) # controla a animacao
animate(plot = meu.plot,duration = 20, fps = 10) # controla a animacao
#Carregar os seguintes pacotes:
library(installr)
library(ForestTools)
library(raster)
library(rgeos)
#Carregar dado de área florestal a ser analisada:
data("kootenayCHM")
#Plotar o CHM (CHM, modelo de altura do dossel):
plot(kootenayCHM)
#Identificar copas de árvore dominantes. Esta função implementa o algoritmo de filtro de janela variável desenvolvido por Popescu e Wynne (2004):
lin <- function(x){x * 0.05 + 0.6}
ttops <- vwf(CHM = kootenayCHM, winFun = lin, minHeight = 2)
#Plotar o CHM:
plot(kootenayCHM, xlab = "", ylab = "", xaxt='n', yaxt = 'n')
#Adicionar as copas das árvores dominantes identificadas a partir do algoritimo no plot CHM:
plot(ttops, col = "blue", pch = 20, cex = 0.5, add = TRUE)
#Ver a altura média das copas calculadas:
mean(ttops$height)
#Os modelos de altura do dossel geralmente representam florestas densas e contínuas, onde as copas das árvores se encostam umas nas outras. O esboço de formas discretas de coroas a partir desse tipo de floresta costuma ser chamado de segmentação de copa, onde cada contorno de coroa é representado por um segmento. Depois que um conjunto de copas das árvores é detectado a partir de um modelo de altura do dossel, a função mcws pode ser usada para essa finalidade.
#Criar mapa de coroas com a função mcws:
crowns <- mcws(treetops = ttops, CHM = kootenayCHM, minHeight = 1.5, verbose = FALSE)
# Plotar as coroas:
plot(crowns, col = sample(rainbow(50), length(unique(crowns[])), replace = TRUE), legend = FALSE, xlab = "", ylab = "", xaxt='n', yaxt = 'n')
#Por padrão, mcws retorna uma varredura, na qual cada coroa recebe um valor único de célula. Dependendo da finalidade do mapa da coroa, pode ser preferível armazenar esses contornos como polígonos. Definir o argumento de formato como "polígonos" converterá o mapa de coroa rasterizado em um conjunto de polígonos. Como um benefício adicional, esses polígonos herdarão os atributos das copas das árvores a partir das quais foram gerados, como a altura. Além disso, um atributo extra, crownArea, será calculado para cada polígono.
#Criar mapa de poligonos a partir das coroas:
crownsPoly <- mcws(treetops = ttops, CHM = kootenayCHM, format = "polygons", minHeight = 1.5, verbose = FALSE)
#Plotar o grid:
plot(gridStats[["heightMean"]], col = heat.colors(255), xlab = "", ylab = "", xaxt='n', yaxt = 'n')
#Os modelos de altura do dossel geralmente representam florestas densas e contínuas, onde as copas das árvores se encostam umas nas outras. O esboço de formas discretas de coroas a partir desse tipo de floresta costuma ser chamado de segmentação de copa, onde cada contorno de coroa é representado por um segmento. Depois que um conjunto de copas das árvores é detectado a partir de um modelo de altura do dossel, a função mcws pode ser usada para essa finalidade.
#Criar mapa de coroas com a função mcws:
crowns <- mcws(treetops = ttops, CHM = kootenayCHM, minHeight = 1.5, verbose = FALSE)
# Plotar as coroas:
plot(crowns, col = sample(rainbow(50), length(unique(crowns[])), replace = TRUE), legend = FALSE, xlab = "", ylab = "", xaxt='n', yaxt = 'n')
#Por padrão, mcws retorna uma varredura, na qual cada coroa recebe um valor único de célula. Dependendo da finalidade do mapa da coroa, pode ser preferível armazenar esses contornos como polígonos. Definir o argumento de formato como "polígonos" converterá o mapa de coroa rasterizado em um conjunto de polígonos. Como um benefício adicional, esses polígonos herdarão os atributos das copas das árvores a partir das quais foram gerados, como a altura. Além disso, um atributo extra, crownArea, será calculado para cada polígono.
#Criar mapa de poligonos a partir das coroas:
crownsPoly <- mcws(treetops = ttops, CHM = kootenayCHM, format = "polygons", minHeight = 1.5, verbose = FALSE)
#Plotar o CHM
plot(kootenayCHM, xlab = "", ylab = "", xaxt='n', yaxt = 'n')
# Adicionar os poligonos das coroas no CHM:
plot(crownsPoly, border = "blue", lwd = 0.5, add = TRUE)
#A função sp_summarise pode ser usada para contar árvores em um conjunto de unidades espaciais, bem como calcular estatísticas dos atributos das árvores.
#Calcular o número de árvores:
sp_summarise(ttops)
#As copas das árvores também podem ser usadas como entrada. Ao definir o argumento das variáveis, sp_summarise gerará estatísticas resumidas dos atributos das árvores. Por padrão, a média, mediana, desvio padrão, mínimo e máximo são calculados, mas funções personalizadas também podem ser usadas.
#Visualizar atributos estatísticos das árvores:
sp_summarise(crownsPoly, variables = c("crownArea", "height"))
#Computar estatísticas de contagem da altura das árvores para blocos de corte:
blockStats <- sp_summarise(ttops, areas = kootenayBlocks, variables = "height")
#Plotar o CHM:
plot(kootenayCHM, xlab = "", ylab = "", xaxt='n', yaxt = 'n')
#Adicionar os blocos no plot:
plot(kootenayBlocks, add = TRUE, border =  "darkmagenta", lwd = 2)
#Adicionar a contagem de números de árvores para cada bloco (área definida):
text(gCentroid(kootenayBlocks, byid = TRUE), blockStats[["TreeCount"]], col = "darkmagenta", font = 2)
#Ver dados estatísticos:
blockStats@data
#Gerar a altura média das árvores dentro da grade de células de 10 m x 10 m em um arquivo raster:
gridStats <- sp_summarise(trees = ttops, grid = 10, variables = "height")
#Ver o nome das layers:
names(gridStats)
#Plotar o grid:
plot(gridStats[["heightMean"]], col = heat.colors(255), xlab = "", ylab = "", xaxt='n', yaxt = 'n')
#Carregar pacote:
library(lidR)
library(raster)
#Carregar uma área florestal de exemplo a partir de imagens LIDAR que será trabalhada:
las = readLAS("https://www.dropbox.com/s/e7mlo11k5qeao2i/Example.las?dl=0")
#Carregar uma área florestal de exemplo a partir de imagens LIDAR que será trabalhada:
las = readLAS("https://www.dropbox.com/s/e7mlo11k5qeao2i/Example.las?dl=1")
plot(las)
#O lasground fornece vários algoritmos para classificar os pontos de referência. Essa função é conveniente para gráficos de pequeno a médio porte, como o que estamos processando.
#Classificar pontos do solo (pontos de referência):
las = lasground(las, csf())
plot(las, color = "Classification")
#É necessário Precisamos definir o terreno em 0 metros. Deve-se subtrair o MDT para obter pontos de aterramento em 0, mas aqui não será usado um MDT, mas vamos interpolar exatamente cada ponto.
#Definir altura normalizada:
las = lasnormalize(las, tin())
plot(las)
#Na próxima etapa, será usado um algoritmo que requer um modelo de altura da copa a partir da nuvem de pontos.
#Calcular um modelo de altura das copas:
algo = pitfree(thresholds = c(0,10,20,30,40,50), subcircle = 0.2)
chm  = grid_canopy(las, 0.5, algo)
#Plotar o CHM:
plot(chm, col = height.colors(50))
#A segmentação pode ser alcançada com lastrees. Aqui foi escolhido o algoritmo de bacia com um limiar de 4 metros. A nuvem de pontos foi atualizada e cada ponto agora tem um número que se refere a uma árvore individual (treeID). Pontos que não são árvores recebem o valor de ID NA.
#Realizar a segmentação das árvores:
algo = watershed(chm, th = 4)
las  = lastrees(las, algo)
# remove points that are not assigned to a tree
trees = lasfilter(las, !is.na(treeID))
#Plotar a segmentação:
plot(trees, color = "treeID", colorPalette = pastel.colors(100))
#Calcular algumas métricas:
hulls  = tree_hulls(las, func = .stdmetrics)
spplot(hulls, "zmax")
#No exemplo anterior, mesmo se a segmentação for feita usando um modelo de altura do dossel, a classificação foi feita na nuvem de pontos. Isso ocorre porque lidR é uma biblioteca orientada à nuvem de pontos. Mas pode-se querer que o raster trabalhe com rasters. Nesse caso, a função divisor de águas pode ser usada de forma independente:
crowns = watershed(chm, th = 4)()
plot(crowns, col = pastel.colors(100))
#Criar poligonos de contornos a partir da copa:
contour = rasterToPolygons(crowns, dissolve = TRUE)
#Plotar o CHM e contornos:
plot(chm, col = height.colors(50))
plot(contour, add = T)
#Carregar uma área florestal de exemplo a partir de imagens LIDAR que será trabalhada:
las = readLAS("https://www.dropbox.com/s/e7mlo11k5qeao2i/Example.las?dl=1")
las = readLAS("https://www.dropbox.com/s/e7mlo11k5qeao2i/Example.las?dl=0")
#Carregar pacote:
library(lidR)
library(raster)
#Carregar uma área florestal de exemplo a partir de imagens LIDAR que será trabalhada:
las = readLAS("https://www.dropbox.com/s/e7mlo11k5qeao2i/Example.las?dl=1")
plot(las)
#Carregar uma área florestal de exemplo a partir de imagens LIDAR que será trabalhada:
las = readLAS(Example.las)
#Carregar uma área florestal de exemplo a partir de imagens LIDAR que será trabalhada:
las = readLAS(C:/Users/Jefferson/Dropbox/Livro/Example.las)
#Carregar uma área florestal de exemplo a partir de imagens LIDAR que será trabalhada:
las = readLAS('C:/Users/Jefferson/Dropbox/Livro/Example.las')
plot(las)
