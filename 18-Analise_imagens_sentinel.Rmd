
## Imagens de satélites

Esse procedimento será realizado com imagens de satélite (Sentinel 2), porêm pode ser aplicado com imagens de RPA, desde que sejam multiespectrais.


Carregar pacotes necessários para trabalhar com os dados raster.
Caso não tenha algum dos pacotes, realize a sua instalação.
```{r eval=T, message=FALSE, include=T}
library(raster)
library(knitr)
library(sp)
library(rgdal)
library(ggplot2)
library(viridis)
library(rasterVis)
library(LSRS)
```

Baixar o arquivo . [sentinel2.tif](https://www.dropbox.com/s/s08rizfs6wls9ml/sentinel2.tif?dl=1).


```{r echo=FALSE}
imagesentinel=raster('D:/livro/TudodoRa/sentinel2.tif')
```

```{r eval=T, include=T}
imagesentinel=raster('sentinel2.tif')
```

Visualizar os dados
```{r}
imagesentinel
```


É necessário criar camadas individuais para cada uma das bandas espectrais:
```{r}
b1 <- raster('sentinel2.tif', band=1)
b2 <- raster('sentinel2.tif', band=2)
b3 <- raster('sentinel2.tif', band=3)
b4 <- raster('sentinel2.tif', band=4)
b5 <- raster('sentinel2.tif', band=5)
b6 <- raster('sentinel2.tif', band=6)
b7 <- raster('sentinel2.tif', band=7)
b8 <- raster('sentinel2.tif', band=8)
b9 <- raster('sentinel2.tif', band=9)
b10 <- raster('sentinel2.tif', band=10)
b11 <- raster('sentinel2.tif', band=11)
b12 <- raster('sentinel2.tif', band=12)
```

Comparar duas bandas para ver se elas possuem a mesma extensão:
```{r}
compareRaster(b2, b3)

```


Plotar a banda 4 para pré-visualização:
```{r}
plot(b4)

image(b4)
```



Visualizar a imagem nas bandas do RGB:
```{r}
RGB <- stack(list(b4, b3, b2))              
plotRGB(RGB, axes = TRUE, stretch = "lin", main = "Sentinel RGB colour composite")
```

Juntar todas as bandas num só arquivo:
```{r}
t <- stack(b1,b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12)
st <- brick('sentinel2.tif')
plot(st)
```

Aplicar o índice de vegetação NDVI, para o Sentinel 2 com: NIR = 8, red = 4.

Criar a VI (vegetation index) por meio de função

```{r}
VI <- function(img, k, i) {
  bk <- img[[k]]
  bi <- img[[i]]
  vi <- (bk - bi) / (bk + bi)
  return(vi)
}
```

*NDVI:*

```{r}
ndvi <- VI(st, 8, 4)
plot(ndvi, col = rev(terrain.colors(10)), main = "Sentinel2-NDVI")
```


**Outras fórmula de aplicar o NDVI**

```{r}
vi2 <- function(x, y) {
  (x - y) / (x + y)
}
ndvi2 <- overlay(st[[8]], st[[4]], fun=vi2)
plot(ndvi2, col=rev(terrain.colors(10)), main="Sentinel2-NDVI")
```


**Visualizar o NDVI em histograma**

```{r}
hist(ndvi,
     main = "Distribuição dos valores de NDVI",
     xlab = "NDVI",
     ylab= "Frequência",
     col = "wheat",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = 'n')
axis(side=1, at = seq(-0.5,1, 0.05), labels = seq(-0.5,1, 0.05))
```

Visualizar apenas a vegetação  com NDVI acima de 0.4:

```{r}
veg <- reclassify(ndvi, cbind(-Inf, 0.4, NA))
plot(veg, main='Vegetação')
```


Reclassificar o NDVI e difini-lo por classes numéricas:

```{r}
vegc <- reclassify(ndvi, c(-Inf,0.25,1, 0.25,0.3,2, 0.3,0.4,3, 0.4,0.5,4, 0.5,Inf, 5))
plot(vegc,col = rev(terrain.colors(4)), main = 'NDVI reclassificado')
```



**Criar uma classificação não supervisionada a partir do NDVI:**

Converter o raster (NDVI) a um vetor/matriz:

```{r}
nr <-getValues(ndvi)
str(nr)
```

É importante definir o gerador de pontos, porque o *"kmeans"* inicia os centros em locais aleatórios: 

```{r}
set.seed(99)
```

Criar 10 clusters, permitir 500 iterações, comece com 5 conjuntos aleatórios usando o método `Lloyd`
```{r}
kmncluster <- kmeans(na.omit(nr), centers = 10, iter.max = 500,
                     nstart = 5, algorithm = "Lloyd")
```

Ver o vetor/matriz:

```{r}
str(kmncluster)
```

Crie uma cópia do NDVI para não perder os dados:

```{r}
knr <- ndvi
```

Agora substitua os valores das células de varredura pelo `kmncluster$cluster`:

```{r}
knr[] <- kmncluster$cluster
```

Realize o plot do NDVI e do kmeans:

```{r}
par(mfrow = c(1, 2))
plot(ndvi, col = rev(terrain.colors(10)), main = "NDVI")
plot(knr, main = "Kmeans", col = viridis_pal(option = "D")(10))
```


Se quiser traçar a classificação kmeans ao lado da renderização  do RGB para verificar a qualidade da classificação e identificação das classes:

```{r}
par(mfrow = c(1, 2))
plotRGB(RGB, axes = FALSE, stretch = "lin", main = "RGB")
plot(knr, main = "Kmeans", yaxt = 'n', col = viridis_pal(option = "D")(10))
```

Aplicar outros índices de vegetação com o `pacote LSRS`:

```{r}
NDVI=NDVI(b8,b4)
SAVI=SAVI(b8,b4)
TGSI=TGSI(b4,b2,b3)
MSAVI=MSAVI(b8,b4, Pixel.Depth=1)
EVI=EVI(b8,b4,b2,Pixel.Depth=1)
NBR=NBR(b8,b11)
```

```{r}
par(mfrow = c(3, 2))
plot(NDVI,lwd=4,main="NDVI",xlab="easting", ylab="northing")
plot(SAVI,lwd=4,main="SAVI",xlab="easting", ylab="northing")
plot(TGSI,lwd=4,main="TGSI",xlab="easting", ylab="northing")
plot(MSAVI,lwd=4,main="MSAVI",xlab="easting", ylab="northing")
plot(EVI,lwd=4,main="EVI",xlab="easting", ylab="northing")
plot(NBR,lwd=4,main="NBR",xlab="easting", ylab="northing")
```


## Curvas de nível e modelo 3D a partir do Modelo Digital de Elevação

Primeiro carregar os pacotes necessários
```{r}
library(raster)
library(plot3D)
```

Carregar o dado raster do pacote Raster (Volcano) para ser usado como exemplo:

```{r}
filled.contour(volcano, color.palette = terrain.colors)
```

Criar as curvas de nível:

```{r}
cont <- contourLines(volcano)
fun <- function(x) x$level
LEVS <- sort(unique(unlist(lapply(cont, fun))))
COLS <- terrain.colors(length(LEVS))
```

Plotar somente as curvas de nível:

```{r}
contour(volcano)
```


Plotar o modelo 3D com curvas de nível:
```{r}
x <- seq(1, nrow(volcano), by = 3)
y <- seq(1, ncol(volcano), by = 3) 
Volcano <- volcano [x, y]
```


Exemplo 1:

```{r}
ribbon3D(z = Volcano, contour = TRUE, zlim= c(-100, 200),image = TRUE)

```


Exemplo 2:
```{r}
persp3D(z = Volcano, contour = TRUE, zlim= c(-200, 200), image = FALSE)

```


Exemplo 3:

```{r}
persp3D(z = Volcano, x = x, y = y, scale = FALSE,contour = list(nlevels = 20, col = "red"),zlim = c(-200, 200), expand = 0.2,image = list(col = grey (seq(0, 1, length.out = 100))))
```

Exemplo 4:

```{r}
persp3D(z = Volcano, contour = list(side = c("zmin", "z", "350")), zlim = c(-100, 400), phi = 20, image = list(side = 350))
```


Exemplo 5:

```{r}
persp3D(z = volcano, shade = 0.3, col = gg.col(100))
```

## Modelo de altura do dossel (CHM) com o MDT e MDE

O modelo de altura da copa (CHM) representa a altura das árvores. Este não é um valor de elevação, é a altura ou a distância entre o chão e o topo das árvores. Alguns modelos de altura da copa também incluem edifícios, portanto, é necessário olhar atentamente para seus dados para garantir que eles foram limpos corretamente antes de assumir que representam todas as árvores

Carregar os pacotes:

```{r message=FALSE}
library(raster)
library(rgdal)
```

Carregar o dado MDE:

```{r}
MDE <- raster("https://www.dropbox.com/s/kifc93rdhz2xykm/DSM.tif?dl=1")
plot(MDE, main = "Modelo Digital de Elevação (DEM)")
```

Carregar o dado MDT:

```{r}
MDT <- raster("https://www.dropbox.com/s/sfbr3blydvxg75v/DTM.tif?dl=1")
plot(MDT, main = "Modelo Digital do Terreno (MDT)")
```

Existem diferentes maneiras de calcular um CHM. Uma maneira fácil é subtrair o MDE do MDT.

Criar o Modelo de Altura do Dossel (CHM):
```{r}
CHM <- MDE - MDT
plot(CHM,main = "Modelo de Altura do Dossel (CHM)")
```

Às vezes, um gradiente de cores é útil para representar uma variável contínua. Outras vezes, porém, é útil aplicar cores a intervalos específicos de valores em uma varredura. Esses intervalos podem ser gerados estatisticamente ou simplesmente visuais.

Criar intervalos (alturas) no CHM:

```{r}
plot(CHM,
     breaks = c(0, 2, 10, 20, 30),
     main = "Modelo de Altura do Dossel",
     col = c("white", "brown", "springgreen", "darkgreen"))
```

É possível salvar o CHM para ser usado em outras plataformas:

```{r eval=F, message=FALSE}
writeRaster(CHM, "CHM.tiff",
            format = "GTiff",
            overwrite = TRUE)
```

Carregar os seguintes pacotes:
```{message=FALSE, include=T}
library(installr)
library(ForestTools)
library(raster)
library(rgeos)
```

Carregar dado de área florestal a ser analisada:
```{r}
data("kootenayCHM")
```

Plotar o CHM (CHM, modelo de altura do dossel):
```{r eval=FALSE }
plot(kootenayCHM)
```

Identificar copas de árvore dominantes. Esta função implementa o algoritmo de filtro de janela variável desenvolvido por Popescu e Wynne (2004):

```{r eval= False}
lin <- function(x){x * 0.05 + 0.6}
ttops <- vwf(CHM = kootenayCHM, winFun = lin, minHeight = 2)
```

Plotar o CHM:
```{r eval=FALSE}
plot(kootenayCHM, xlab = "", ylab = "", xaxt='n', yaxt = 'n')
```

Adicionar as copas das árvores dominantes identificadas a partir do algoritimo no plot CHM:
```{r eval=FALSE}
plot(ttops, col = "blue", pch = 20, cex = 0.5, add = TRUE)
```

Ver a altura média das copas calculadas:
```{r}
mean(ttops$height)
```

Os modelos de altura do dossel geralmente representam florestas densas e contínuas, onde as copas das árvores se encostam umas nas outras. O esboço de formas discretas de coroas a partir desse tipo de floresta costuma ser chamado de segmentação de copa, onde cada contorno de coroa é representado por um segmento. Depois que um conjunto de copas das árvores é detectado a partir de um modelo de altura do dossel, a função `mcws` pode ser usada para essa finalidade.

Criar mapa de coroas com a função `mcws`:
```{r}
crowns <- mcws(treetops = ttops, CHM = kootenayCHM, minHeight = 1.5, verbose = FALSE)

```

Plotar as coroas:
```{r}
plot(crowns, col = sample(rainbow(50), length(unique(crowns[])), replace = TRUE), legend = FALSE, xlab = "", ylab = "", xaxt='n', yaxt = 'n')
```

Por padrão, mcws retorna uma varredura, na qual cada coroa recebe um valor único de célula. Dependendo da finalidade do mapa da coroa, pode ser preferível armazenar esses contornos como polígonos. Definir o argumento de formato como "polígonos" converterá o mapa de coroa rasterizado em um conjunto de polígonos. Como um benefício adicional, esses polígonos herdarão os atributos das copas das árvores a partir das quais foram gerados, como a altura. Além disso, um atributo extra, `crownArea`, será calculado para cada polígono.

Criar mapa de poligonos a partir das coroas:
```{r}
crownsPoly <- mcws(treetops = ttops, CHM = kootenayCHM, format = "polygons", minHeight = 1.5, verbose = FALSE)
```

Plotar o CHM
```{r}
plot(kootenayCHM, xlab = "", ylab = "", xaxt='n', yaxt = 'n')
```

Adicionar os poligonos das coroas no CHM:
```{r eval=FALSE}
plot(crownsPoly, border = "blue", lwd = 0.5, add = TRUE)

```

A função `sp_summarise` pode ser usada para contar árvores em um conjunto de unidades espaciais, bem como calcular estatísticas dos atributos das árvores.

Calcular o número de árvores:
```{r}
sp_summarise(ttops)
```

As copas das árvores também podem ser usadas como entrada. Ao definir o argumento das variáveis, `sp_summarise` gerará estatísticas resumidas dos atributos das árvores. Por padrão, a média, mediana, desvio padrão, mínimo e máximo são calculados, mas funções personalizadas também podem ser usadas.

Visualizar atributos estatísticos das árvores:
```{r}
sp_summarise(crownsPoly, variables = c("crownArea", "height"))
```


O pacote `Forest Tools` inclui os limites de três blocos de corte que podem ser sobrepostos no `kootenayCHM`. As contagens de árvores e estatísticas de altura podem ser resumidas dentro desses limites usando o argumento de áreas.

Carregados dados:
```{r}
data("kootenayBlocks")
```

Computar estatísticas de contagem da altura das árvores para blocos de corte:
```{r}
blockStats <- sp_summarise(ttops, areas = kootenayBlocks, variables = "height")
```

Plotar o CHM:
```{r}
plot(kootenayCHM, xlab = "", ylab = "", xaxt='n', yaxt = 'n')

```

Adicionar os blocos no plot: 
```{r eval=FALSE}
plot(kootenayBlocks, add = TRUE, border =  "darkmagenta", lwd = 2)
```

Adicionar a contagem de números de árvores para cada bloco (área definida):
```{r}
text(gCentroid(kootenayBlocks, byid = TRUE), blockStats[["TreeCount"]], col = "darkmagenta", font = 2)
```

Ver dados estatísticos:
```{r}
blockStats@data
```

Gerar a altura média das árvores dentro da grade de células de 10 m x 10 m em um arquivo raster:

```{r}
gridStats <- sp_summarise(trees = ttops, grid = 10, variables = "height")
```

Ver o nome das layers:
```{r}
names(gridStats)
```

Plotar o grid:
```{r}
plot(gridStats[["heightMean"]], col = heat.colors(255), xlab = "", ylab = "", xaxt='n', yaxt = 'n')
```

## LIDAR
O exemplo a seguir é um processamento de imagens LIDAR, por meio da qual será segmentado árvores individuais e métricas.

Carregar pacote:
```{r message=FALSE}
library(lidR)
library(raster)
```

Baixar dados
[Example.las]('https://www.dropbox.com/s/e7mlo11k5qeao2i/Example.las?dl=1')

Carregar uma área florestal de exemplo a partir de imagens LIDAR que será trabalhada:
```{r}
las = readLAS('C:/Users/Jefferson/Dropbox/Livro/Example.las')
plot(las)
```


O lasground fornece vários algoritmos para classificar os pontos de referência. Essa função é conveniente para gráficos de pequeno a médio porte, como o que estamos processando.

Classificar pontos do solo (pontos de referência):
```{r}
las = lasground(las, csf())
plot(las, color = "Classification")
```


É necessário  definir o terreno em 0 metros. Deve-se subtrair o MDT para obter pontos de aterramento em 0, mas aqui não será usado um MDT, mas vamos interpolar exatamente cada ponto.

Definir altura normalizada:
```{r}
las = lasnormalize(las, tin())
plot(las)
```


Na próxima etapa, será usado um algoritmo que requer um modelo de altura da copa a partir da nuvem de pontos.

Calcular um modelo de altura das copas:

```{r}
algo = pitfree(thresholds = c(0,10,20,30,40,50), subcircle = 0.2)
chm  = grid_canopy(las, 0.5, algo)
```

Plotar o CHM:
```{r}
plot(chm, col = height.colors(50))
```

A segmentação pode ser alcançada com `lastrees`. Aqui foi escolhido o algoritmo de bacia com um limiar de 4 metros. A nuvem de pontos foi atualizada e cada ponto agora tem um número que se refere a uma árvore individual (treeID). Pontos que não são árvores recebem o valor de ID NA.

Realizar a segmentação das árvores:
```{r}
algo = watershed(chm, th = 4)
las  = lastrees(las, algo)
```

remove points that are not assigned to a tree
```{r}
trees = lasfilter(las, !is.na(treeID))
```

Plotar a segmentação:
```{r}
plot(trees, color = "treeID", colorPalette = pastel.colors(100))

```

Calcular algumas métricas:
```{r}
hulls  = tree_hulls(las, func = .stdmetrics)
spplot(hulls, "zmax")
```

No exemplo anterior, mesmo se a segmentação for feita usando um modelo de altura do dossel, a classificação foi feita na nuvem de pontos. Isso ocorre porque `lidR` é uma biblioteca orientada à nuvem de pontos. Mas pode-se querer que o raster trabalhe com rasters. Nesse caso, a função divisor de águas pode ser usada de forma independente:

```{r}
crowns = watershed(chm, th = 4)()
plot(crowns, col = pastel.colors(100))
```

Criar poligonos de contornos a partir da copa: 
```{r}
contour = rasterToPolygons(crowns, dissolve = TRUE)
```

Plotar o CHM e contornos:
```{r}
plot(chm, col = height.colors(50))
plot(contour, add = T)
```


## Informações topográficas a partir do Modelo Digital de Elevação MDE##

Carregar pacotes:
```{r message=FALSE}
library(raster)
```

Carregar dados e plotar :
```{r}
MDE=raster("https://www.dropbox.com/s/b2rzimq500rmj5o/MDE.tif?dl=1")
plot(MDE)
```

Usar a função `terrain()` para calcular/extrair algumas informações topográficas:
```{r}
Declividade <- terrain(MDE, "slope")
Aspecto <- terrain(MDE, "aspect")
TPI <- terrain(MDE, "TPI") # Topographic Position Index (Índice de posição topográfica)
TRI <- terrain(MDE, "TRI") # Terrain Ruggedness Index (Índice de robustez do terreno)
Rugosidade <- terrain(MDE, "roughness")
Escoamento <- terrain(MDE, "flowdir")
Hillshade <- hillShade(Declividade, Aspecto, angle=45, direction=0, filename='', normalize=FALSE)
```

Juntar todos os dados com a função `stack()`:
```{r}
topo <- stack(MDE, Declividade, Aspecto, TPI, TRI, Rugosidade, Escoamento, Hillshade)

```

Renomear os dados para aparecerem no `plot`:
```{r}
names(topo) <- c("MDE", "Declividade","Aspecto", "TPI", "TRI", "Rugosidade", "Escoamento", "Hillshade")
```

Plotar os dados:
```{r}
plot(topo)
```








