
## Imagens de satélites

Esse procedimento será realizado com imagens de satélite (Sentinel 2), porêm pode ser aplicado com imagens de RPA, desde que sejam multiespectrais.


Carregar pacotes necessários para trabalhar com os dados raster.
Caso não tenha algum dos pacotes, realize a sua instalação.
```{r eval=T, include=T}
library(raster)
library(knitr)
library(sp)
library(rgdal)
library(ggplot2)
library(viridis)
library(rasterVis)
library(LSRS)
```

Baixar o arquivo . [sentinel2.tif](https://www.dropbox.com/s/s08rizfs6wls9ml/sentinel2.tif?dl=1).


```{r eval=T, include=T}
imagesentinel=raster('D:/livro/TudodoRa/sentinel2.tif')
```

```{r eval=T, include=T}
imagesentinel=raster('sentinel2.tif')
```

Visualizar os dados
```{r}
imagesentinel
```


É necessário criar camadas individuais para cada uma das bandas espectrais:
```{r}
b1 <- raster('sentinel2.tif', band=1)
b2 <- raster('sentinel2.tif', band=2)
b3 <- raster('sentinel2.tif', band=3)
b4 <- raster('sentinel2.tif', band=4)
b5 <- raster('sentinel2.tif', band=5)
b6 <- raster('sentinel2.tif', band=6)
b7 <- raster('sentinel2.tif', band=7)
b8 <- raster('sentinel2.tif', band=8)
b9 <- raster('sentinel2.tif', band=9)
b10 <- raster('sentinel2.tif', band=10)
b11 <- raster('sentinel2.tif', band=11)
b12 <- raster('sentinel2.tif', band=12)
```

Comparar duas bandas para ver se elas possuem a mesma extensão:
```{r}
compareRaster(b2, b3)

```


Plotar a banda 4 para pré-visualização:
```{r}
plot(b4)

image(b4)
```



Visualizar a imagem nas bandas do RGB:
```{r}
RGB <- stack(list(b4, b3, b2))              
plotRGB(RGB, axes = TRUE, stretch = "lin", main = "Sentinel RGB colour composite")
```

Juntar todas as bandas num só arquivo:
```{r}
t <- stack(b1,b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12)
st <- brick('sentinel2.tif')
plot(st)
```

Aplicar o índice de vegetação NDVI, para o Sentinel 2 com: NIR = 8, red = 4.

Criar a VI (vegetation index) por meio de função

```{r}
VI <- function(img, k, i) {
  bk <- img[[k]]
  bi <- img[[i]]
  vi <- (bk - bi) / (bk + bi)
  return(vi)
}
```

*NDVI:*

```{r}
ndvi <- VI(st, 8, 4)
plot(ndvi, col = rev(terrain.colors(10)), main = "Sentinel2-NDVI")
```


**Outras fórmula de aplicar o NDVI**

```{r}
vi2 <- function(x, y) {
  (x - y) / (x + y)
}
ndvi2 <- overlay(st[[8]], st[[4]], fun=vi2)
plot(ndvi2, col=rev(terrain.colors(10)), main="Sentinel2-NDVI")
```


**Visualizar o NDVI em histograma**

```{r}
hist(ndvi,
     main = "Distribuição dos valores de NDVI",
     xlab = "NDVI",
     ylab= "Frequência",
     col = "wheat",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = 'n')
axis(side=1, at = seq(-0.5,1, 0.05), labels = seq(-0.5,1, 0.05))
```

Visualizar apenas a vegetação  com NDVI acima de 0.4:

```{r}
veg <- reclassify(ndvi, cbind(-Inf, 0.4, NA))
plot(veg, main='Vegetação')
```


Reclassificar o NDVI e difini-lo por classes numéricas:

```{r}
vegc <- reclassify(ndvi, c(-Inf,0.25,1, 0.25,0.3,2, 0.3,0.4,3, 0.4,0.5,4, 0.5,Inf, 5))
plot(vegc,col = rev(terrain.colors(4)), main = 'NDVI reclassificado')
```



**Criar uma classificação não supervisionada a partir do NDVI:**

Converter o raster (NDVI) a um vetor/matriz:

```{r}
nr <-getValues(ndvi)
str(nr)
```

É importante definir o gerador de pontos, porque o *"kmeans"* inicia os centros em locais aleatórios: 

```{r}
set.seed(99)
```

Criar 10 clusters, permitir 500 iterações, comece com 5 conjuntos aleatórios usando o método `Lloyd`
```{r}
kmncluster <- kmeans(na.omit(nr), centers = 10, iter.max = 500,
                     nstart = 5, algorithm = "Lloyd")
```

Ver o vetor/matriz:

```{r}
str(kmncluster)
```

Crie uma cópia do NDVI para não perder os dados:

```{r}
knr <- ndvi
```

Agora substitua os valores das células de varredura pelo `kmncluster$cluster`:

```{r}
knr[] <- kmncluster$cluster
```

Realize o plot do NDVI e do kmeans:

```{r}
par(mfrow = c(1, 2))
plot(ndvi, col = rev(terrain.colors(10)), main = "NDVI")
plot(knr, main = "Kmeans", col = viridis_pal(option = "D")(10))
```


Se quiser traçar a classificação kmeans ao lado da renderização  do RGB para verificar a qualidade da classificação e identificação das classes:

```{r}
par(mfrow = c(1, 2))
plotRGB(RGB, axes = FALSE, stretch = "lin", main = "RGB")
plot(knr, main = "Kmeans", yaxt = 'n', col = viridis_pal(option = "D")(10))
```

Aplicar outros índices de vegetação com o `pacote LSRS`:

```{r}
NDVI=NDVI(b8,b4)
SAVI=SAVI(b8,b4)
TGSI=TGSI(b4,b2,b3)
MSAVI=MSAVI(b8,b4, Pixel.Depth=1)
EVI=EVI(b8,b4,b2,Pixel.Depth=1)
NBR=NBR(b8,b11)
```

```{r}
par(mfrow = c(3, 2))
plot(NDVI,lwd=4,main="NDVI",xlab="easting", ylab="northing")
plot(SAVI,lwd=4,main="SAVI",xlab="easting", ylab="northing")
plot(TGSI,lwd=4,main="TGSI",xlab="easting", ylab="northing")
plot(MSAVI,lwd=4,main="MSAVI",xlab="easting", ylab="northing")
plot(EVI,lwd=4,main="EVI",xlab="easting", ylab="northing")
plot(NBR,lwd=4,main="NBR",xlab="easting", ylab="northing")
```


## Curvas de nível e modelo 3D a partir do Modelo Digital de Elevação

Primeiro carregar os pacotes necessários
```{r}
library(raster)
library(plot3D)
```

Carregar o dado raster do pacote Raster (Volcano) para ser usado como exemplo:

```{r}
filled.contour(volcano, color.palette = terrain.colors)
```

Criar as curvas de nível:

```{r}
cont <- contourLines(volcano)
fun <- function(x) x$level
LEVS <- sort(unique(unlist(lapply(cont, fun))))
COLS <- terrain.colors(length(LEVS))
```

Plotar somente as curvas de nível:

```{r}
contour(volcano)
```


Plotar o modelo 3D com curvas de nível:
```{r}
x <- seq(1, nrow(volcano), by = 3)
y <- seq(1, ncol(volcano), by = 3) 
Volcano <- volcano [x, y]
```


Exemplo 1:

```{r}
ribbon3D(z = Volcano, contour = TRUE, zlim= c(-100, 200),image = TRUE)

```


Exemplo 2:
```{r}
persp3D(z = Volcano, contour = TRUE, zlim= c(-200, 200), image = FALSE)

```


Exemplo 3:

```{r}
persp3D(z = Volcano, x = x, y = y, scale = FALSE,contour = list(nlevels = 20, col = "red"),zlim = c(-200, 200), expand = 0.2,image = list(col = grey (seq(0, 1, length.out = 100))))
```

Exemplo 4:

```{r}
persp3D(z = Volcano, contour = list(side = c("zmin", "z", "350")), zlim = c(-100, 400), phi = 20, image = list(side = 350))
```


Exemplo 5:

```{r}
persp3D(z = volcano, shade = 0.3, col = gg.col(100))
```

## Modelo de altura do dossel (CHM) com o MDT e MDE

O modelo de altura da copa (CHM) representa a altura das árvores. Este não é um valor de elevação, é a altura ou a distância entre o chão e o topo das árvores. Alguns modelos de altura da copa também incluem edifícios, portanto, é necessário olhar atentamente para seus dados para garantir que eles foram limpos corretamente antes de assumir que representam todas as árvores

Carregar os pacotes:

```{r}
library(raster)
library(rgdal)
```

Carregar o dado MDE:

```{r}
MDE <- raster("https://www.dropbox.com/s/kifc93rdhz2xykm/DSM.tif?dl=1")
plot(MDE, main = "Modelo Digital de Elevação (DEM)")
```

Carregar o dado MDT:

```{r}
MDT <- raster("https://www.dropbox.com/s/sfbr3blydvxg75v/DTM.tif?dl=1")
plot(MDT, main = "Modelo Digital do Terreno (MDT)")
```

Existem diferentes maneiras de calcular um CHM. Uma maneira fácil é subtrair o MDE do MDT.

Criar o Modelo de Altura do Dossel (CHM):
```{r}
CHM <- MDE - MDT
plot(CHM,main = "Modelo de Altura do Dossel (CHM)")
```

Às vezes, um gradiente de cores é útil para representar uma variável contínua. Outras vezes, porém, é útil aplicar cores a intervalos específicos de valores em uma varredura. Esses intervalos podem ser gerados estatisticamente ou simplesmente visuais.

Criar intervalos (alturas) no CHM:

```{r}
plot(CHM,
     breaks = c(0, 2, 10, 20, 30),
     main = "Modelo de Altura do Dossel",
     col = c("white", "brown", "springgreen", "darkgreen"))
```

É possível salvar o CHM para ser usado em outras plataformas:

```{r}
writeRaster(CHM, "CHM.tiff",
            format = "GTiff",
            overwrite = TRUE)
```







