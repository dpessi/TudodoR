[
["index.html", "Uso do sistema R para análise de dados 1 Pré requisitos", " Uso do sistema R para análise de dados 2020-04-15 1 Pré requisitos Material em construção. Este material, em forma de notas de aula, foi escrito para a disciplina do Mestrado em Engenharia Agrícola, intitulado Uso do sistema R para análise de dados, no primeiro semestre de 2018. Estas notas de aulas é uma coletânea de apostilas, livros, sites, forum e cursos voltando ao sistema R. Foi utilizado desses materiais sua estrutura didática e rotinas que foram adaptados para o perfil da disciplina. O material consultado encontra-se referenciado no final de cada capitulo. "],
["intro.html", " 2 R Básico 2.1 Expressões 2.2 Valores Booleanos 2.3 Variáveis 2.4 Funções 2.5 Ajuda 2.6 Referência", " 2 R Básico Este primeio capitulo foi baseado no curso on-line Code School Try R e Datacamp, modificações foram realizadas utilizando outros materiais que se encontram referenciado no final do Capitulo. Iremos abordar as expressões básicas do R. Começaremos simples, com números, strings e valores true/false. Em seguida, mostraremos como armazenar esses valores em variáveis e como transmiti-los as funções. Como obter ajuda sobre as funções e no final vamos carregar um arquivo 2.1 Expressões Vamos tentar matemática simples. Digite o comando abaixo e aperte enter 2+8 ## [1] 10 Note que é impresso o resultado, 10. Digite a frase “Engenharia Agrícola” &quot;Engenharia Agrícola&quot; ## [1] &quot;Engenharia Agrícola&quot; Agora tente multiplicar 6 vezes 5 (* é o operador de multiplicação). 6*5 ## [1] 30 2.2 Valores Booleanos Algumas expressões retornam um “valor lógico”: TRUE ou FALSE e/ou “booleanos”. Vamos tentar digitar uma expressões que nos dá um valor lógico: 7&lt;12 ## [1] TRUE E outro valor lógico (sinal duplo de igualdade) 6+5==10 ## [1] FALSE T e F são taquigrafia para TRUE e FALSE. Tente isso: F==FALSE ## [1] TRUE 2.3 Variáveis Você pode armazenar valores em uma variável para usar mais tarde. Digite x &lt;- 28 para armazenar um valor em x. x&lt;-28 Tende dividr x por 4( / é o operador da divisão). x/4 ## [1] 7 Você pode retribuir qualquer valor a uma variável a qualquer momento. Tente atribuir “Engenharia Agrícola”em x. x &lt;- &quot;Engenharia Agrícola&quot; Tente imprimir o valor atual de x. x ## [1] &quot;Engenharia Agrícola&quot; 2.4 Funções Você pode chamar uma função digitando seu nome, seguido de um ou mais argumentos para essa função entre parênteses. Vamos tentar usar a função sum(), para adicionar alguns números. Entrar: sum (2, 4, 6) ## [1] 12 Alguns argumentos têm nomes. Por exemplo, para repetir um valor 3 vezes, você chamaria a função rep e forneceria seu argumento times: rep(&quot;Engenharia Agrícola&quot;, times=3) ## [1] &quot;Engenharia Agrícola&quot; &quot;Engenharia Agrícola&quot; &quot;Engenharia Agrícola&quot; Tente chamar a função sqrt para obter a raiz quadrada 16. sqrt(16) ## [1] 4 2.5 Ajuda A função help () traz ajuda para a função desejada. Tente exibir ajuda para a função mean: help (mean) ## starting httpd help server ... done A função example () traz exemplos de usos. Tente exibir exemplos para a função min: example(min) ## ## min&gt; require(stats); require(graphics) ## ## min&gt; min(5:1, pi) #-&gt; one number ## [1] 1 ## ## min&gt; pmin(5:1, pi) #-&gt; 5 numbers ## [1] 3.141593 3.141593 3.000000 2.000000 1.000000 ## ## min&gt; x &lt;- sort(rnorm(100)); cH &lt;- 1.35 ## ## min&gt; pmin(cH, quantile(x)) # no names ## [1] -2.4911607 -0.4332203 0.1493286 0.7335102 1.3500000 ## ## min&gt; pmin(quantile(x), cH) # has names ## 0% 25% 50% 75% 100% ## -2.4911607 -0.4332203 0.1493286 0.7335102 1.3500000 ## ## min&gt; plot(x, pmin(cH, pmax(-cH, x)), type = &quot;b&quot;, main = &quot;Huber&#39;s function&quot;) ## ## min&gt; cut01 &lt;- function(x) pmax(pmin(x, 1), 0) ## ## min&gt; curve( x^2 - 1/4, -1.4, 1.5, col = 2) ## ## min&gt; curve(cut01(x^2 - 1/4), col = &quot;blue&quot;, add = TRUE, n = 500) ## ## min&gt; ## pmax(), pmin() preserve attributes of *first* argument ## min&gt; D &lt;- diag(x = (3:1)/4) ; n0 &lt;- numeric() ## ## min&gt; stopifnot(identical(D, cut01(D) ), ## min+ identical(n0, cut01(n0)), ## min+ identical(n0, cut01(NULL)), ## min+ identical(n0, pmax(3:1, n0, 2)), ## min+ identical(n0, pmax(n0, 4))) 2.6 Referência MELO, M. P.; PETERNELI, L. A. Conhecendo o R: Um visão mais que estatística. Viçosa, MG: UFV, 2013. 222p. Prof. Paulo Justiniando Ribeiro &gt;http://www.leg.ufpr.br/~paulojus/&lt; Prof. Adriano Azevedo Filho &gt;http://rpubs.com/adriano/esalq2012inicial&lt; Prof. Fernando de Pol Mayer &gt;https://fernandomayer.github.io/ce083-2016-2/&lt; Site Interativo Datacamp &gt;https://www.datacamp.com/&lt; "],
["estruturas-de-dados.html", " 3 Estruturas de Dados 3.1 Vetor 3.2 Matrizes 3.3 Fatores 3.4 Array 3.5 Data.frame 3.6 Lista 3.7 Referência", " 3 Estruturas de Dados Este segundo Capitulo foi baseado no curso on-line Code School Try R e no livro Conhecendo o R: Um visão mais que estatística, modificações foram realizadas utilizando outros materiais que se encontram referenciado no final do Capitulo. 3.1 Vetor Um vetor é simplesmente uma lista de valores. A maneira mais simples de usar um vetor é usando o comando c(), que concatena elementos num mesmo objeto. Exemplo x&lt;- c(2,3,5,7,11) x ## [1] 2 3 5 7 11 Os argumentos de c() podem ser tanto elementos únicos quanto outros objetos. Adicione três números no vetor x y&lt;- c(x,13,17,19) y ## [1] 2 3 5 7 11 13 17 19 3.1.1 Vetores de Sequência Se você precisa de um vetor com uma sequência de números, você pode cria-lo com a notação start:end. Vamos fazer um vetor com valores de 1 a 7: 1:7 ## [1] 1 2 3 4 5 6 7 Uma maneira mais versátil de fazer sequências é chamar a função seq. Vamos fazer o mesmo com seq () : seq(1:7) ## [1] 1 2 3 4 5 6 7 A função seq também permite que você use incrementos diferentes de 1. Experimente com etapas de 0.5. seq(1,7,0.5) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 seq(7,1,-0.5) ## [1] 7.0 6.5 6.0 5.5 5.0 4.5 4.0 3.5 3.0 2.5 2.0 1.5 1.0 Todo objeto possui atributos intrínsecos: tipo e tamanho. Com relação ao tipo ele pode ser: numérico, caractere, complexo e lógico. Existem outros tipos, como por exemplo, funções ou expressões, porém esses não representam dados. As funções mode() e length() mostram o tipo e tamanho de um objeto, respectivamente. z&lt;-c(1,3,5,7,11) mode (z) ## [1] &quot;numeric&quot; length(z) ## [1] 5 a &lt;- &quot;Angela&quot; b&lt;-TRUE; c&lt;-8i #objetos com tipos diferentes mode(a); ## [1] &quot;character&quot; mode(b); ## [1] &quot;logical&quot; mode(c) #exibe os atributos &quot;tipo&quot; dos objetos ## [1] &quot;complex&quot; Se o vetor é muito longo e não “cabe” em uma linha o R vai usar as linhas seguintes para continuar imprimindo o vetor. longo&lt;-100:50 #sequência decrescente de 100 a 50 longo #exibe o conteúdo do objeto ## [1] 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 ## [20] 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 ## [39] 62 61 60 59 58 57 56 55 54 53 52 51 50 Os números entre colchetes não fazem parte do objeto e indica a posição do vetor naquele ponto. Pode-se ver que [1] indica que o primeiro elemento do vetor estão naquela linha, [17] indica que a linha seguinte começa pelo décimo setimo elemento do vetor e assim por diante. Você pode recuperar um valor individual dentro de um vetor fornecendo seu índice numérico entre colchetes. Tente obter o valor 18: longo[18] ## [1] 83 Muitas línguagem de programação iniciam índices de matriz em 0, mas os índices vetoriais de R começam em 1. Obtenha o primeiro valor digitando: longo[1] ## [1] 100 Você pode atribuir novos valores dentro de um vetor existente. Tente mudar o terceiro valor 28: longo [3] &lt;- 28 Se você adicionar novos valores ao final, o vetor aumentará para acomodá-los. Vamos adicionar um valor no final longo[101] &lt;- 83 Você pode usar um vetor entre os colchetes para acessar vários valores. Tente obter a primeira e a terceira palavras longo[c(1,3)] ## [1] 100 28 Isso significa que você pode recuperar intervalos de valores. Obter a segunda a quarta palavras: longo[2:4] ## [1] 99 28 97 Você também pode definir intervalos de valores; apenas forneça os valores em um vetor. Adicione valores 5 a 7: longo[5:7] &lt;- c(42,52,75) Agora tente acessar o oitavo valor do vetor: longo[8] ## [1] 93 3.1.2 Nomes de vetores Para esse desafio, criaremos um vetor de 3 itens e armazená-lo na variável solo. Você pode atribuir nomes aos elementos de um vetor passando um segundo vetor preenchido com os nomes com a função names (), assim: solo &lt;- 1:3 names(solo) &lt;- c(&quot;Argila&quot;, &quot;Areia&quot;,&quot;Silte&quot; ) solo ## Argila Areia Silte ## 1 2 3 Agora, defina o valor atual para o silte para um valor diferente usando o nome em vez da posição. solo[&quot;Silte&quot;]&lt;-20 3.1.3 Plotando um vetor A função barplot () desenha um gráfico de barras com os valores de um vetor. Vamos criar um novo vetor para você e armazená-lo na variável chuva. Agora, tente passar o vetor para a função barplot: chuva &lt;- c(20,50,85) barplot(chuva) Se você atribuir nomes aos valores do vetor, o R usará esses nomes como rótulos no gráfico da barra. Vamos usar a função names () novamente: names(chuva)&lt;- c(&quot;Rondonópolis&quot;, &quot;Maringá&quot;, &quot;Cruzeiro do Sul&quot;) Agora, se você digitar barplot (chuva) com o vetor novamente, você verá os rótulos: barplot(chuva) Agora, tente chamar barplot em um vetor de números inteiros que variam de 1 a 100: barplot(1:100) 3.1.4 Operações matemáticas A maioria das operações aritméticas funcionam tão bem em vetores quanto em valores únicos. Vamos fazer outro vetor de exemplo para você trabalhar e armazená-lo a variável a Se você adicionar um escalar (um único valor) a um vetor, o escalar será adicionado a cada valor no vetor, retornando um novo vetor com os resultados. Tente adicionar 1 a cada elemento em nosso vetor: a &lt;- c(1, 2, 3) a + 1 ## [1] 2 3 4 O mesmo se aplica na divisão, multiplicação ou qualquer outra aritmética básica. Tente dividir nosso vetor por 2: a / 2 ## [1] 0.5 1.0 1.5 Agora, tente multiplicar nosso vetor por 2: a*2 ## [1] 2 4 6 Se você adicionar dois vetores, R irá tirar cada valor de cada vetor e adicioná-los. Vamos fazer um segundo vetor para você experimentar e armazená-lo na variável b Tente adicioná-lo ao vetor a: b &lt;- c(4,5,6) a+b ## [1] 5 7 9 Agora tente subtrair b de a: a-b ## [1] -3 -3 -3 Você também pode tirar dois vetores e comparar cada item. Veja quais valores nos vetores são iguais aos de um segundo vetor a == c(1, 99, 3) ## [1] TRUE FALSE TRUE Observe que R não testou se os vetores inteiros eram iguais; verificou cada valor no vetor a contra o valor no mesmo índice no nosso novo vetor. Verifique se cada valor nos vetores são menores que o valor correspondente em outro vetor: a &lt; c(1, 99, 3) ## [1] FALSE TRUE FALSE Funções que normalmente funcionam com escalares também podem operar em cada elemento de um vetor. Tente obter o seno de cada valor em nosso vetor: sin(a) ## [1] 0.8414710 0.9092974 0.1411200 Agora tente obter as raízes quadradas com a função sqrt: sqrt(a) ## [1] 1.000000 1.414214 1.732051 3.1.5 Parcelas de dispersão A função plot leva dois vetores, um para valores X e um para valores Y, e desenha um gráfico deles. Vamos desenhar um gráfico que mostra a relação de números e seus senos. Primeiro, precisaremos de alguns dados de amostra. Criaremos um vetor com alguns valores fracionários entre 0 e 20, e armazenó-lo na variável x. E na variável y um segundo vetor com os senos de x: x &lt;- seq(1, 20, 0.1) y&lt;-sin(x) Em seguida, basta chamar a função plot com seus dois vetores: plot(x, y) Observa=se sobre o gráfico que os valores do primeiro argumento (x) são usados para o eixo horizontal, e os valores do segundo (y) para o vertical. Vamos criar um vetor com alguns valores negativos e positivos para você e armazenó-lo na variável valores. Também criaremos um segundo vetor com os valores absolutos do primeiro e armazenó-lo na variável absoluto. Tente traçar os vetores, com os valores no eixo horizontal e no eixo vertical os absoluto. valores &lt;- -10:10 absoluto&lt;- abs(valores) plot(valores, absoluto) 3.1.6 Valores Faltantes As vezes, ao trabalhar com dados de amostra, um determinado valor não está disponível. Mas não é uma boa idéia apenas tirar esses valores. R tem um valor que indica explicitamente uma amostra não estava disponível: NA. Muitas funções que funcionam com vetores tratam esse valor especialmente. Vamos criar um vetor para você com uma amostra ausente e armazenó-lo na variével a. Tente obter a soma de seus valores e veja qual é o resultado: a &lt;- c(1, 3, NA, 7, 9) sum(a) ## [1] NA A soma é considerada “não disponível” por padrão porque um dos valores do vetor foi NA. Lembre-se desse comando para mostrar ajuda para uma função. Apresente a ajuda para a função sum: help(sum) Como você vê na documentação, sum pode tomar um argumento opcional na.rm,. ? configurado FALSE por padrão, mas se você configurá-lo com TRUE, todos os argumentos NA serão removidos do vetor antes do cálculo ser executado. Tente rondar sum novamente, com o na.rm conjunto para TRUE: sum(a, na.rm = T) ## [1] 20 3.2 Matrizes Há varias formas de criar uma matriz. O comando matriz() recebe um vetor como argumento e o transfoma em uma matrix de acordo com as dimensões. Vamos fazer uma matriz de 3 linhas de altura por 4 colunas de largura, com todos os seus campos definidos 0. matrix(0,3,4) ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 0 ## [2,] 0 0 0 0 ## [3,] 0 0 0 0 Você também pode usar um vetor para inicializar o valor de uma matriz. Para preencher uma matriz de 3x4, você precisará de um vetor de 12 itens. a &lt;- (1:12) print (a) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 Agora chame matrix com o vetor, o número de linhas e o número de colunas: matrix (a,# chama o vetor 3,# linha 4) #coluna ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Você também pode usar um vetor para inicializar o valor de uma matriz. Para preencher uma matriz 3x4, você precisará de um vetor de 12 itens. Nós vamos fazer isso para você agora: a &lt;-1:12 a ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 Agora chame matrix com o vetor, o número de linhas e o número de colunas: matrix (a,3,4) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 3.2.1 Outras formas matrix (a, 3) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Note que as matrizes são preenchidas ao longo das colunas. Para que a matriz seja preenchida por linhas deve-se alterar o argumento byrow, que, por padrão, está definido como FALSE, passe para TRUE matrix(a,3, byrow=T) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Os valores do vetor são copiados para a nova matriz, um por um. Você também pode reformular o próprio vetor em uma matriz. Crie um vetor de 8 itens: foliar &lt;- 1:8 A função dim define as dimensões para uma matriz. Ele aceita um vetor com o número de linhas e o n?mero de colunas a serem atribu?das. Atribua novas dimens?es para foliar passando um vetor especificando 2 linhas e 4 colunas ( c(2, 4)): dim(foliar) &lt;- c(2,4) O vetor não é mais unidimensional. Foi convertido, no local, para uma matriz. Agora, use a função matrix para criar uma matriz 5x5, com seus campos inicializados para qualquer valor que você desejar. matrix (2,5,5) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 2 2 2 2 2 ## [2,] 2 2 2 2 2 ## [3,] 2 2 2 2 2 ## [4,] 2 2 2 2 2 ## [5,] 2 2 2 2 2 3.2.2 Acesso a Matriz Obter valores de matrizes não é diferente de vetores; você só precisa fornecer dois índices em vez de um. Abra a matriz foliar: print (foliar) ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 7 ## [2,] 2 4 6 8 Tente obter o valor da segunda linha na terceira coluna da matriz foliar; foliar[2,3] ## [1] 6 O valor da primeira linha da quarta coluna foliar[1,4] ## [1] 7 Você pode obter uma linha inteira da matriz omitindo o índice da coluna (mas mantenha a virgula). Tente recuperar a segunda linha: foliar[2,] ## [1] 2 4 6 8 Para obter uma coluna inteira, omita o índice da linha. Recupere a quarta coluna: foliar[,4] ## [1] 7 8 Você pode ler várias linhas ou colunas, fornecendo um vetor ou sequência com seus índices. Tente recuperar as colunas de 2 a 4: foliar[,2:4] ## [,1] [,2] [,3] ## [1,] 3 5 7 ## [2,] 4 6 8 O comando summary pode ser usado para obter informações da matriz summary(foliar) ## V1 V2 V3 V4 ## Min. :1.00 Min. :3.00 Min. :5.00 Min. :7.00 ## 1st Qu.:1.25 1st Qu.:3.25 1st Qu.:5.25 1st Qu.:7.25 ## Median :1.50 Median :3.50 Median :5.50 Median :7.50 ## Mean :1.50 Mean :3.50 Mean :5.50 Mean :7.50 ## 3rd Qu.:1.75 3rd Qu.:3.75 3rd Qu.:5.75 3rd Qu.:7.75 ## Max. :2.00 Max. :4.00 Max. :6.00 Max. :8.00 Se desejar um resumo de todos os elementos da matriz, basta transformá-la em um vetor summary(as.vector(foliar)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 2.75 4.50 4.50 6.25 8.00 3.2.3 Visualizações em dados matriciais Com um mapa de elevação. Tudo fica a 1 metro acima do nível do mar. Vamos criar uma matriz de 10 por 10 com todos os seus valores inicializados para 1 para você: elevacao &lt;- matrix (1,10,10) Na quarta linha, sexta coluna, defina a elevação para 0: elevacao [4, 6] &lt;- 0 Mapa de contorno dos valores passando a matriz para a função contour contour(elevacao) Criar um gráfico em perspectiva 3D com a função persp: persp (elevacao) Podemos consertar isso especificando nosso próprio valor para o parâmetro expand. persp (elevacao, expand =0.2) R inclui alguns conjuntos de dados de amostra. Um deles é o volcanoum mapa 3D de um vulcão adormecido da Nova Zelândia. É simplesmente uma matriz de 87x61 com valores de elevão, mas mostra o poder das visualizações de matriz do R. Criar um mapa de calor: contour(volcano) Gráfico em perspectiva: persp(volcano, expand=0.2) A função image criar um mapa de calor: image(volcano) 3.2.4 Mais informações sobre construções de Matrizes Há outros comandos que podem ser usados para construir matrizes como cbind() e rbind (). Esses comandos concatenam colunas ou linhas, respectivamente, na matriz (ou vetor). a &lt;- matrix (10:1,ncol=2) #construir uma matriz qualquer a ## [,1] [,2] ## [1,] 10 5 ## [2,] 9 4 ## [3,] 8 3 ## [4,] 7 2 ## [5,] 6 1 b &lt;- cbind (a,1:5) #adicionar uma terceira coluna b ## [,1] [,2] [,3] ## [1,] 10 5 1 ## [2,] 9 4 2 ## [3,] 8 3 3 ## [4,] 7 2 4 ## [5,] 6 1 5 c&lt;- rbind(b,c(28,28,28)) c ## [,1] [,2] [,3] ## [1,] 10 5 1 ## [2,] 9 4 2 ## [3,] 8 3 3 ## [4,] 7 2 4 ## [5,] 6 1 5 ## [6,] 28 28 28 Opcionalmente matrizes podem ter nomes associados ás linhas e colunas (“rownames”e “colnames”). Cada um destes componentes da matrix é um vetor de nomes. m1 &lt;- matrix(1:12, ncol = 3) dimnames(m1) &lt;- list(c(&quot;L1&quot;, &quot;L2&quot;, &quot;L3&quot;, &quot;L4&quot;), c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;)) dimnames(m1) ## [[1]] ## [1] &quot;L1&quot; &quot;L2&quot; &quot;L3&quot; &quot;L4&quot; ## ## [[2]] ## [1] &quot;C1&quot; &quot;C2&quot; &quot;C3&quot; Matrizes são muitas vezes utilizadas para armazenar frequências de cruzamentos entre variáveis. Desta forma é comum surgir a necessidade de obter os totais marginais, isto é a soma dos elementos das linhas e/ou colunas das matrizes, o que pode ser diretamente obtido com margin.table( ). margin.table(m1, margin = 1) ## L1 L2 L3 L4 ## 15 18 21 24 margin.table(m1, margin = 2) ## C1 C2 C3 ## 10 26 42 apply(m1, 2, median) ## C1 C2 C3 ## 2.5 6.5 10.5 3.3 Fatores Os fatores são vetores em que os elementos pertencem a uma ou mais categorias temáticas. Por exemplo: ao criar um vetor de indicadores de “tratamentos” em uma análise de experimentos devemos declarar este vetor como um “fator”. Pode criar um fator usando o comando factor(), ou o comando gl. factor(rep(paste(&quot;T&quot;, 1:3, sep = &quot;&quot;), c(4, 4, 3))) ## [1] T1 T1 T1 T1 T2 T2 T2 T2 T3 T3 T3 ## Levels: T1 T2 T3 peso &lt;- c(134.8, 139.7, 147.6, 132.3, 161.7, 157.7, 150.3, 144.7, 160.7, 172.7, 163.4, 161.3, 169.8, 168.2, 160.7, 161.0, 165.7, 160.0, 158.2, 151.0, 171.8, 157.3, 150.4, 160.4, 154.5, 160.4, 148.8, 154.0) trat &lt;- rep(seq(0,300,50), each=4) #?each dados &lt;- data.frame(peso, trat=as.factor(trat)) 3.4 Array O conceito de array generaliza a idéia de matrix. Enquanto em uma matrix os elementos são organizados em duas dimensões (linhas e colunas), em um array os elementos podem ser organizados em um número arbitrário de dimensões. No R um array é definido utilizando a função array(). ar1 &lt;- array(1:24, dim = c(3, 4, 2)) ar1 ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 13 16 19 22 ## [2,] 14 17 20 23 ## [3,] 15 18 21 24 Veja agora um exemplo de dados já incluído no R no formato de array. Para “carregar” e visualizar os dados digite: data(Titanic) Titanic ## , , Age = Child, Survived = No ## ## Sex ## Class Male Female ## 1st 0 0 ## 2nd 0 0 ## 3rd 35 17 ## Crew 0 0 ## ## , , Age = Adult, Survived = No ## ## Sex ## Class Male Female ## 1st 118 4 ## 2nd 154 13 ## 3rd 387 89 ## Crew 670 3 ## ## , , Age = Child, Survived = Yes ## ## Sex ## Class Male Female ## 1st 5 1 ## 2nd 11 13 ## 3rd 13 14 ## Crew 0 0 ## ## , , Age = Adult, Survived = Yes ## ## Sex ## Class Male Female ## 1st 57 140 ## 2nd 14 80 ## 3rd 75 76 ## Crew 192 20 Para obter maiores informações sobre estes dados digite: help(Titanic) Agora vamos responder ás seguintes perguntas, mostrando os comandos do R utilizados sobre o array de dados. Quantas pessoas havia no total? sum(Titanic) ## [1] 2201 Quantas pessoas havia na tripulação (crew)? sum(Titanic[4, , , ]) ## [1] 885 Quantas pessoas sobreviveram e quantas morreram? apply(Titanic, 4, sum) ## No Yes ## 1490 711 Quais as proporções de sobreviventes entre homens e mulheres? margin.table(Titanic, margin = 1) ## Class ## 1st 2nd 3rd Crew ## 325 285 706 885 margin.table(Titanic, margin = 2) ## Sex ## Male Female ## 1731 470 margin.table(Titanic, margin = 3) ## Age ## Child Adult ## 109 2092 margin.table(Titanic, margin = 4) ## Survived ## No Yes ## 1490 711 Esta função admite ainda índices múltiplos que permitem outros resumos da tabela de dados. Por exemplo mostramos a seguir como obter o total de sobreviventes e não sobreviventes, separados por sexo e depois as porcentagens de sobreviventes para cada sexo. margin.table(Titanic, margin = c(2, 4)) ## Survived ## Sex No Yes ## Male 1364 367 ## Female 126 344 prop.table(margin.table(Titanic, margin = c(2, 4)), margin = 1) ## Survived ## Sex No Yes ## Male 0.7879838 0.2120162 ## Female 0.2680851 0.7319149 prop.table(margin.table(Titanic, margin = c(2, 1)), margin = 1) ## Class ## Sex 1st 2nd 3rd Crew ## Male 0.10398614 0.10340843 0.29462738 0.49797805 ## Female 0.30851064 0.22553191 0.41702128 0.04893617 3.5 Data.frame Os datas.frames são muitos semelhantes ás matrizes, pois têm linhas e colunas e, portanto, duas dimensões. Entretando, diferentemente das matrizes, colunas diferentes podem armazenar elementos de tipos diferentes. Por exemplo, a primeira coluna pode ser numérica, enquanto a segunda, constituida de caracteres. Cada coluna precisa ter o mesmo tamanho. Criar o vetor nomes nome &lt;- c(&quot;Melissa José&quot;, &quot;Jennifer Linhares&quot;, &quot;Gedilene Ponciano&quot;, &quot;Edinar da Silva&quot;, &quot;Osmar Emidio&quot;, &quot;Jeeziel Vieira&quot;) Criar vetor idade idade &lt;- c(17,18,16,15,15,18) Criar vetor sexo (categoria=fator) sexo &lt;- factor(c(&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;F&quot;,&quot;M&quot;,&quot;M&quot;)) Criar vetor altura alt &lt;- c(180,170,160,150,140,168) Reunir tudo em um data.frame dados &lt;- data.frame(nome, idade, sexo, alt) Ver atributos da tabela str(dados) ## &#39;data.frame&#39;: 6 obs. of 4 variables: ## $ nome : Factor w/ 6 levels &quot;Edinar da Silva&quot;,..: 5 4 2 1 6 3 ## $ idade: num 17 18 16 15 15 18 ## $ sexo : Factor w/ 2 levels &quot;F&quot;,&quot;M&quot;: 1 1 1 1 2 2 ## $ alt : num 180 170 160 150 140 168 Adicionar nome as linhas com o comando row.names() row.names(dados) &lt;- c(1,2,3,4,5,6) dados ## nome idade sexo alt ## 1 Melissa José 17 F 180 ## 2 Jennifer Linhares 18 F 170 ## 3 Gedilene Ponciano 16 F 160 ## 4 Edinar da Silva 15 F 150 ## 5 Osmar Emidio 15 M 140 ## 6 Jeeziel Vieira 18 M 168 names(dados) &lt;- c(&quot;Nome&quot;, &quot;Idade&quot;, &quot;Sexo&quot;, &quot;altura&quot;) dados ## Nome Idade Sexo altura ## 1 Melissa José 17 F 180 ## 2 Jennifer Linhares 18 F 170 ## 3 Gedilene Ponciano 16 F 160 ## 4 Edinar da Silva 15 F 150 ## 5 Osmar Emidio 15 M 140 ## 6 Jeeziel Vieira 18 M 168 3.5.1 Índice dos Data.frames Buscar elementos dados[2,1] #elemento da linha 2, coluna 1 ## [1] Jennifer Linhares ## 6 Levels: Edinar da Silva Gedilene Ponciano ... Osmar Emidio dados[2,] #toda linha dois ## Nome Idade Sexo altura ## 2 Jennifer Linhares 18 F 170 Repare que apesar de “Nomes” ter sido criado como vetor de caracterer o R passou a entender como um fator dentro do data.frame. dados[,1] ## [1] Melissa José Jennifer Linhares Gedilene Ponciano Edinar da Silva ## [5] Osmar Emidio Jeeziel Vieira ## 6 Levels: Edinar da Silva Gedilene Ponciano ... Osmar Emidio Transformar para caracterer dados[,1] &lt;- as.character(dados[,1]) dados[,1] ## [1] &quot;Melissa José&quot; &quot;Jennifer Linhares&quot; &quot;Gedilene Ponciano&quot; ## [4] &quot;Edinar da Silva&quot; &quot;Osmar Emidio&quot; &quot;Jeeziel Vieira&quot; Acessando aos dados dados$Nome ## [1] &quot;Melissa José&quot; &quot;Jennifer Linhares&quot; &quot;Gedilene Ponciano&quot; ## [4] &quot;Edinar da Silva&quot; &quot;Osmar Emidio&quot; &quot;Jeeziel Vieira&quot; dados$Nome[3] ## [1] &quot;Gedilene Ponciano&quot; dados$Nome [1:3] ## [1] &quot;Melissa José&quot; &quot;Jennifer Linhares&quot; &quot;Gedilene Ponciano&quot; str(dados) ## &#39;data.frame&#39;: 6 obs. of 4 variables: ## $ Nome : chr &quot;Melissa José&quot; &quot;Jennifer Linhares&quot; &quot;Gedilene Ponciano&quot; &quot;Edinar da Silva&quot; ... ## $ Idade : num 17 18 16 15 15 18 ## $ Sexo : Factor w/ 2 levels &quot;F&quot;,&quot;M&quot;: 1 1 1 1 2 2 ## $ altura: num 180 170 160 150 140 168 3.5.2 Manipulando um Data.frame Você pode manipular um data.frame add ou eliminando colunas ou linhas, assim como em matrizes. Podem-se usar os comandos cbind() e rbind () para adcionar colunas e linhas rescpectivamente, a um data.frame. dados &lt;- cbind (dados, #adicionar uma coluna Conceito=c(&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;)) dados &lt;- rbind (dados, #adicionar uma linha &quot;7&quot;= c(&quot;Caio Pinto&quot;, 21, &quot;M&quot;, 172, &quot;C&quot;)) dados ## Nome Idade Sexo altura Conceito ## 1 Melissa José 17 F 180 A ## 2 Jennifer Linhares 18 F 170 A ## 3 Gedilene Ponciano 16 F 160 A ## 4 Edinar da Silva 15 F 150 C ## 5 Osmar Emidio 15 M 140 A ## 6 Jeeziel Vieira 18 M 168 B ## 7 Caio Pinto 21 M 172 C Assim como para vetores e matrizes voce pode selecinar um subgrupo de um data.frame e armazena-lo em um outro objeto ou utilizar índices como o sinal negativo para eliminar linhas ou colunas de um data.frame. dados&lt;- dados [1:6,] #selecionar linha de 1 a 6 dados&lt;- dados [,-5] #excluir a quinta coluna dados ## Nome Idade Sexo altura ## 1 Melissa José 17 F 180 ## 2 Jennifer Linhares 18 F 170 ## 3 Gedilene Ponciano 16 F 160 ## 4 Edinar da Silva 15 F 150 ## 5 Osmar Emidio 15 M 140 ## 6 Jeeziel Vieira 18 M 168 dados[dados$Sexo==&quot;F&quot;,] #exibir só masculinos ## Nome Idade Sexo altura ## 1 Melissa José 17 F 180 ## 2 Jennifer Linhares 18 F 170 ## 3 Gedilene Ponciano 16 F 160 ## 4 Edinar da Silva 15 F 150 A ordenação das linhas de um data.frame segundo os dados contidos em determinadas coluna também é extremamente útil dados [order(dados$altura),] ## Nome Idade Sexo altura ## 5 Osmar Emidio 15 M 140 ## 4 Edinar da Silva 15 F 150 ## 3 Gedilene Ponciano 16 F 160 ## 6 Jeeziel Vieira 18 M 168 ## 2 Jennifer Linhares 18 F 170 ## 1 Melissa José 17 F 180 dados [rev(order(dados$altura)),] ## Nome Idade Sexo altura ## 1 Melissa José 17 F 180 ## 2 Jennifer Linhares 18 F 170 ## 6 Jeeziel Vieira 18 M 168 ## 3 Gedilene Ponciano 16 F 160 ## 4 Edinar da Silva 15 F 150 ## 5 Osmar Emidio 15 M 140 3.5.3 Separando um data.frame por grupos split (dados, sexo) ## $F ## Nome Idade Sexo altura ## 1 Melissa José 17 F 180 ## 2 Jennifer Linhares 18 F 170 ## 3 Gedilene Ponciano 16 F 160 ## 4 Edinar da Silva 15 F 150 ## ## $M ## Nome Idade Sexo altura ## 5 Osmar Emidio 15 M 140 ## 6 Jeeziel Vieira 18 M 168 3.6 Lista Lista são objetos muito úteis, pois são usados para combinar diferente estruturas de dados em um mesmo objeto, ou seja, vetores, matrizes, arrays, data.frames e ate mesmo outras listas. pes &lt;- list (idade=32, nome=&quot;Maria&quot;, notas=c(98,95,78), B=matrix(1:4,2,2)) pes ## $idade ## [1] 32 ## ## $nome ## [1] &quot;Maria&quot; ## ## $notas ## [1] 98 95 78 ## ## $B ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Lista são construidas com o comando list (). Quando você exibe um objeto que é uma lista, cada componente é mostrado com seu nome $ ou [ ] 3.6.1 Alguns comandos que retornam listas Muitos comando do R retornam seu resultado na forma de listas. Um exemplo pode ser mostrado com o uso do comando t.tes(), que retorna um objeto que é uma lista. x &lt;- c(1,3,2,3,4) y &lt;- c(4,5,5,4,4) tt &lt;- t.test (x,y, var.equal=T) tt ## ## Two Sample t-test ## ## data: x and y ## t = -3.182, df = 8, p-value = 0.01296 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -3.1044729 -0.4955271 ## sample estimates: ## mean of x mean of y ## 2.6 4.4 Comprovar que é uma lista is.list(tt) ## [1] TRUE mode (tt) ## [1] &quot;list&quot; Exibir o componentes da lista names(tt) ## [1] &quot;statistic&quot; &quot;parameter&quot; &quot;p.value&quot; &quot;conf.int&quot; &quot;estimate&quot; ## [6] &quot;null.value&quot; &quot;stderr&quot; &quot;alternative&quot; &quot;method&quot; &quot;data.name&quot; tt$conf.int #intervalo de confianca ## [1] -3.1044729 -0.4955271 ## attr(,&quot;conf.level&quot;) ## [1] 0.95 3.7 Referência MELO, M. P.; PETERNELI, L. A. Conhecendo o R: Um visão mais que estatística. Viçosa, MG: UFV, 2013. 222p. Prof. Paulo Justiniando Ribeiro &gt;http://www.leg.ufpr.br/~paulojus/&lt; Prof. Adriano Azevedo Filho &gt;http://rpubs.com/adriano/esalq2012inicial&lt; Prof. Fernando de Pol Mayer &gt;https://fernandomayer.github.io/ce083-2016-2/&lt; Site Interativo Datacamp &gt;https://www.datacamp.com/&lt; "],
["entrada-de-dados.html", " 4 Entrada de dados 4.1 Onde os dados devem estar? 4.2 Entrando com dados 4.3 Salvar objetos de dados 4.4 Referência", " 4 Entrada de dados Este terceiro Capitulo foi baseado no livro Conhecendo o R: Um visão mais que estatística, e na página do Prof. Paulo Justiniando Ribeiro modificações foram realizadas utilizando outros materiais que se encontram referenciado no final do Capitulo. O diretorio de trabalho é aquele usado pelo R para gravar, ler, importar e exportar arquivos quando nenhum outro caminho é explicitado. 4.1 Onde os dados devem estar? Para saber onde os diretorios estão basta digitar o comando getwd() getwd() #para verificar diretório de trabalho ## [1] &quot;D:/livro/TudodoRa&quot; Caso queira alterar o diretorio de trabalho para um outro qualquer digite o comando setwd() setwd(&quot;C:/R_Curso&quot;) #para altear o diretório de trabalho Outra forma de mudar o caminho é com o comando: caminho&lt;-file.choose() # ou usando as teclhas shift + Crtl + H Este comando irá abrir uma tela para que o usuário navegue nas pastas e escolha o arquivo a ser aberto. Você pode exibir o conteudo do diretório com o comando dir() dir() ## [1] &quot;_bookdown.yml&quot; &quot;_bookdown_files&quot; ## [3] &quot;_output.yml&quot; &quot;01-R_basico.Rmd&quot; ## [5] &quot;02-Estrutura_basica.Rmd&quot; &quot;03-Entrada_dados.Rmd&quot; ## [7] &quot;04-Criando_graficos.Rmd&quot; &quot;05-Criando_graficos_2.Rmd&quot; ## [9] &quot;06-Teste_T_corre.Rmd&quot; &quot;07-Anova_dic.Rmd&quot; ## [11] &quot;08-Anova_DBC.Rmd&quot; &quot;09-Anova_QL.Rmd&quot; ## [13] &quot;10-Regressao_L_M.Rmd&quot; &quot;11-Regressao_N_linear.Rmd&quot; ## [15] &quot;12-Resolucao_Livro.Rmd&quot; &quot;13-Dados_clima.Rmd&quot; ## [17] &quot;14-Dados_tempor.Rmd&quot; &quot;15-Extrair_dados.Rmd&quot; ## [19] &quot;16-Tendencia_tempora.Rmd&quot; &quot;17-Analise_imagens.Rmd&quot; ## [21] &quot;18-Analise_imagens_sentinel.Rmd&quot; &quot;19-Referencia.Rmd&quot; ## [23] &quot;book.bib&quot; &quot;docs&quot; ## [25] &quot;index.Rmd&quot; &quot;LICENSE&quot; ## [27] &quot;packages.bib&quot; &quot;preamble.tex&quot; ## [29] &quot;README.md&quot; &quot;search_index.json&quot; ## [31] &quot;sentinel2.tif&quot; &quot;style.css&quot; ## [33] &quot;tab.xls&quot; &quot;TudodoR.log&quot; ## [35] &quot;TudodoR.Rmd&quot; &quot;TudodoR.Rproj&quot; ## [37] &quot;TudodoR.tex&quot; &quot;TudodoR_files&quot; 4.2 Entrando com dados O formato mais adequado vai depender do tamanho do conjunto de dados, e se os dados já existem em outro formato para serem importados ou se serão digitados diretamente no R. A seguir são descritas formas de entrada de dados com indicão de quando cada uma das formas deve ser usada. 4.2.1 Vetores Podemos entrar com dados definindo vetores com o comando c(), conforme visto no capítulo 3. vetor &lt;- c(2,5,7) Esta forma de entrada de dados é conveniente quando se tem um pequeno número de dados. Quando os dados tem algum elementos repetidos, números sequenciais pode-se usar mecanismos do R para facilitar a entrada dos dados como vetores. vetor &lt;- rep(c(2,5), 5) # cria vetor repetindo 5 vezes 2 e 5 alternadamente vetor ## [1] 2 5 2 5 2 5 2 5 2 5 vetor &lt;- rep(c(5,8), each=3) # cria vetor repetindo 3 vezes 5 e depois 8 vetor ## [1] 5 5 5 8 8 8 4.2.2 Usando a função ‘scan’ Esta função coloca o modo prompt onde o usuário deve digitar cada dado seguido da tecla . Para encerrar a entrada de dados basta digitar duas vezes consecutivas. Veja o seguinte resultado: y &lt;- scan() #1: 11 #2: 24 #3: 35 #4: 29 #5: 39 #6: 47 #7: #Read 6 items y ## numeric(0) #[1] 11 24 35 29 39 47 Este formato é mais ágil que o anterior e mais conveniente para digitar vetores longos. 4.2.3 Copiar e colar usando scan() Pode usar o recurso “copiar e colar” com o comando scan. Após copiar os dados (crtl+C), digite no prompt/console o comando scan(), aperte &gt;ENTER&lt;, depois cole o texto e, aperte &gt;ENTER&lt; novamente. 4.2.4 Lendo dados através da área de transferência Funções como scan(), read.table() e outras podem usadas para ler os dados diretamente da área de transferência passando-se ao “clipboard” ao primeiro argumento. 4.2.5 Usando a função edit O comando edit(data.frame()) abre uma planilha para digitação de dados que são armazanados como data-frames. dados &lt;- edit(data.frame()) data-frame Se voce precisar abrir novamente planilha com os dados, para fazer modificações e/ou inserir mais dados use o comando fix. fix(dados) head(dados) ## data frame with 0 columns and 0 rows 4.2.5.1 Exemplo 1 teste &lt;- c(10,20,30,40,50) teste ## [1] 10 20 30 40 50 Porém houve um erro: o último elemento deveria ser 60 e não 50, você não precisar criar novamente um objeto, use o comando edit() teste2 &lt;- edit(teste) edit 4.2.5.2 Exemplo 2 Com uma planilha com três colunas de dados. Os valores numéricos da coluna poderiam ser importados para o R utilizando-se o mesmo processo ora descrito com o uso do comando scan(). Abra o arquivo . EVI-prec.xlsx. Uma matrix com os dados poderá ser obtida com o comando cbind dados &lt;- cbind(ano, chuva, evi) Os objeto dados é um data.frame is.data.frame(dados) Transforme para um data.frame com o comando as.data.frame dados_m &lt;- as.data.frame(dados) Poderia usar o comando data.frame direto dados=data.frame (ano, chuva, evi) 4.2.6 Lendo dados de um arquivo texto É muito importante ter os dados tabulados em um arquivo-texto ou em outros formatos que permitem a conversão para dados texto. O comando read.table () é extremamente útil por ler dados de um arquivo-texto no formato de um data.frame Usando o Comando read.table () 4.2.6.1 Exemplo 1 Como primeiro exemplo considere importar para o R os dados do arquivo texto exemplo1.txt. ex01 &lt;- read.table(&quot;exemplo1.txt&quot;) #Use os comandos ex01 class(ex01) names(ex01) dim(ex01) str(ex01) head(ex01) 4.2.6.2 Exemplo 2 Como primeiro exemplo considere importar para o R os dados do arquivo de texto exemplo2.txt. ex02 &lt;- read.table(&quot;exemplo2.txt&quot;) ex02 Note que este arquivo difere do anterior em um aspecto: os nomes das variáveis estão na primeira linha. Para que o R considere isto corretamente temos que informá-lo disto com o argumento head=T. Portanto para importar este arquivo usamos: ex02 &lt;- read.table(&quot;exemplo02.txt&quot;, head=T) ex02 4.2.7 Dados do tipo CSV Exemplo3.csv: Vamos utilizar um arquivo de tipo CSV. ex03 &lt;- read.table(&quot;exemplo3.csv.&quot;, head=T, sep=&quot;:&quot;, dec=&quot;,&quot;) ex03 Note que este arquivo difere do primeiro em outros aspectos. read.table. ex03 &lt;- read.table( # lê dados de um arquivo texto &quot;exemplo3.csv&quot;, # nome do arquivo ou o caminho c:/R.exemplo3.csv head=T, # primeira linha ? cabe?alho sep=&quot;:&quot;, # separador de coluna dec=&quot;,&quot;) # virgula como separador ex03 # exibe o objeto 1.sep: caractere utilizado para separação dos campos e valores. Normalmente é utilizado o ponto e virgula (;) 1.dec: caractere utilizado para separar as casas decimais. Normalmente ponto (.) ou virgula (,). 1.header: TRUE, assume que a primeira linha da tabela contêm rotulos das variáveis. ‘FALSE’, assume que os dados se iniciam na primeira linha. 4.2.8 A seguir listamos algumas destas funções: read.dbf() para arquivos DBASE read.epiinfo() para arquivos .REC do Epi-Info read.mtp() para arquivos “Minitab Portable Worksheet” read.S() para arquivos do S-PLUS, e restore.data() para “dumps” do S-PLUS read.spss() para dados do SPSS read.systat() para dados do SYSTAT read.dta() para dados do STATA read.octave() para dados do OCTAVE (um clone do MATLAB) read.csv(file, header = TRUE, sep=“,”, dec=“.”) read.csv2(file, header = TRUE, sep=“;”, dec=“,”) read.delim(file, header = TRUE, sep=“, dec=”.\") read.delim2(file, header = TRUE, sep=“, dec=”,\") 4.2.9 Lendo dados disponíveis na web Exemplo 4: As funções permitem ler ainda dados diretamente disponíveis na web. Por exemplo os dados do exemplo1.txt poderiam ser lidos diretamente com o comando a seguir 4.2.10 Lendo dados de uma planilha eletrônica Com o pacote xlsx é possivel ler os dados diretamente da planilha eletrônica do Excel. install.packages(&quot;&quot;) require(&quot;xlsx&quot;) O comando read.xlsx(), do pacote xlsx, lê o conteúdo de uma planilha eletrônica para o R com a estrutura de dados de um data.frame. dados &lt;- read.xlsx( file=&quot;C:/R/EVI_Prec.xlsx&quot;, #comando que lê planilhas sheetName = &quot;Conbea&quot;, #nome da planilha h=T) #sem cabeçalho 4.2.11 Exercícios Baixe os seguintes arquivos: BanzattoQd1.2.3.txt BanzattoQd3.2.1.txt BanzattoQd3.4.1.txt Coloque os arquivos em um local apropriado (de preferncia no mesmo diretorio de trabalho que voce definiu no início da sessão), faça a importação usando a função de sua escolha, e confira a estrutura dos dados com ´str()´. 4.3 Salvar objetos de dados Salvar objetos de dados nos formatos .txt ou .csv função: write.table sintaxe da função: write.table(x, file, sep=\"“, dec=”\", rownames = T, col.names = T) Principais argumentos: 1. x - matriz ou data frame 1. file - nome do arquivo ou caminho do arquivo 1. sep - separador da coluna 1. dec - separador deciminal 4.3.1 Outras funções write.csv() write.csv2() write.xlsx () Exemplo: write.xlsx(dados,“tabela salva.xlsx”) 4.4 Referência MELO, M. P.; PETERNELI, L. A. Conhecendo o R: Um visão mais que estatística. Viçosa, MG: UFV, 2013. 222p. Prof. Paulo Justiniando Ribeiro &gt;http://www.leg.ufpr.br/~paulojus/&lt; Prof. Adriano Azevedo Filho &gt;http://rpubs.com/adriano/esalq2012inicial&lt; Prof. Fernando de Pol Mayer &gt;https://fernandomayer.github.io/ce083-2016-2/&lt; "],
["criando-gráficos-com-o-r.html", " 5 Criando Gráficos com o R 5.1 Exemplos de gráficos com o R 5.2 Entrada de dados 5.3 Usando a função plot() 5.4 Histogramas 5.5 Gráficos de Barras 5.6 Boxplots 5.7 Cores 5.8 Interagindo com a Janela gráfica 5.9 Texto e tamanho do símbolo 5.10 Visualizar vários gráficos 5.11 Salvando gráficos", " 5 Criando Gráficos com o R Este capitulo foi baseado nos livros Conhecendo o R: Um visão mais que estatística AQUINO, J. A. R para cientistas sociais. - Ilhéus, BA: EDITUS, 2014. 157. ANJOS, A. Análise gráfica com uso do R. Apostila. Dep. de Estatistica da UFPR, 2016. 127p. Sites https://www.statmethods.net/index.html http://curso-r.github.io/index.html PET Estatística UFPR (2016). labestData: Biblioteca de Dados para Aprendizado de Estatística. R package version x.y-z.w. https://www.statmethods.net/index.html Modificações foram realizadas utilizando outros materiais que se encontram referenciado no final do Capitulo. O R é uma poderosa ferramenta no que diz respeito à confeção de gráficos. Iremos abordar três categorias de comandos gráficos, com o uso do pacote báscico do R o graphics\". Alguns pacotes foram desenvolvidos especialmente para manipulação de gráficos, como lattice, ggplot2, ggobi* e rgl. O R possui diferentes funções geradoras de gráficos, e essas são classificados como: Funções gráficas de alto nível: criam novos gráficos na janela, definindo eixos, título, etc. Exemplos: plot, hist, image, contour, persp etc. Funções gráficas de baixo nível: permitem adicionar novas informações em gráficos já criados, como novos dados, linhas etc. Exemplos: points, lines, abline, polygon, legend etc. Funções gráficas iterativas: permitem retirar ou adicionar informações aos gráficos já existentes, usando por exemplo o cursor do mouse. Exemplos: locator e identify. 5.1 Exemplos de gráficos com o R Você pode ver alguns exemplos de gráficos que podem ser criados no R com os seguintes comandos: demo(image) ## ## ## demo(image) ## ---- ~~~~~ ## ## &gt; # Copyright (C) 1997-2009 The R Core Team ## &gt; ## &gt; require(datasets) ## ## &gt; require(grDevices); require(graphics) ## ## &gt; x &lt;- 10*(1:nrow(volcano)); x.at &lt;- seq(100, 800, by=100) ## ## &gt; y &lt;- 10*(1:ncol(volcano)); y.at &lt;- seq(100, 600, by=100) ## ## &gt; # Using Terrain Colors ## &gt; ## &gt; image(x, y, volcano, col=terrain.colors(100),axes=FALSE) ## ## &gt; contour(x, y, volcano, levels=seq(90, 200, by=5), add=TRUE, col=&quot;brown&quot;) ## ## &gt; axis(1, at=x.at) ## ## &gt; axis(2, at=y.at) ## ## &gt; box() ## ## &gt; title(main=&quot;Maunga Whau Volcano&quot;, sub = &quot;col=terrain.colors(100)&quot;, font.main=4) ## ## &gt; # Using Heat Colors ## &gt; ## &gt; image(x, y, volcano, col=heat.colors(100), axes=FALSE) ## ## &gt; contour(x, y, volcano, levels=seq(90, 200, by=5), add=TRUE, col=&quot;brown&quot;) ## ## &gt; axis(1, at=x.at) ## ## &gt; axis(2, at=y.at) ## ## &gt; box() ## ## &gt; title(main=&quot;Maunga Whau Volcano&quot;, sub = &quot;col=heat.colors(100)&quot;, font.main=4) ## ## &gt; # Using Gray Scale ## &gt; ## &gt; image(x, y, volcano, col=gray(100:200/200), axes=FALSE) ## ## &gt; contour(x, y, volcano, levels=seq(90, 200, by=5), add=TRUE, col=&quot;black&quot;) ## ## &gt; axis(1, at=x.at) ## ## &gt; axis(2, at=y.at) ## ## &gt; box() ## ## &gt; title(main=&quot;Maunga Whau Volcano \\n col=gray(100:200/200)&quot;, font.main=4) ## ## &gt; ## Filled Contours are even nicer sometimes : ## &gt; example(filled.contour) ## ## flld.c&gt; require(&quot;grDevices&quot;) # for colours ## ## flld.c&gt; filled.contour(volcano, asp = 1) # simple ## ## flld.c&gt; x &lt;- 10*1:nrow(volcano) ## ## flld.c&gt; y &lt;- 10*1:ncol(volcano) ## ## flld.c&gt; filled.contour(x, y, volcano, color = function(n) hcl.colors(n, &quot;terrain&quot;), ## flld.c+ plot.title = title(main = &quot;The Topography of Maunga Whau&quot;, ## flld.c+ xlab = &quot;Meters North&quot;, ylab = &quot;Meters West&quot;), ## flld.c+ plot.axes = { axis(1, seq(100, 800, by = 100)) ## flld.c+ axis(2, seq(100, 600, by = 100)) }, ## flld.c+ key.title = title(main = &quot;Height\\n(meters)&quot;), ## flld.c+ key.axes = axis(4, seq(90, 190, by = 10))) # maybe also asp = 1 ## ## flld.c&gt; mtext(paste(&quot;filled.contour(.) from&quot;, R.version.string), ## flld.c+ side = 1, line = 4, adj = 1, cex = .66) ## ## flld.c&gt; # Annotating a filled contour plot ## flld.c&gt; a &lt;- expand.grid(1:20, 1:20) ## ## flld.c&gt; b &lt;- matrix(a[,1] + a[,2], 20) ## ## flld.c&gt; filled.contour(x = 1:20, y = 1:20, z = b, ## flld.c+ plot.axes = { axis(1); axis(2); points(10, 10) }) ## ## flld.c&gt; ## Persian Rug Art: ## flld.c&gt; x &lt;- y &lt;- seq(-4*pi, 4*pi, len = 27) ## ## flld.c&gt; r &lt;- sqrt(outer(x^2, y^2, &quot;+&quot;)) ## ## flld.c&gt; filled.contour(cos(r^2)*exp(-r/(2*pi)), axes = FALSE) ## ## flld.c&gt; ## rather, the key *should* be labeled: ## flld.c&gt; filled.contour(cos(r^2)*exp(-r/(2*pi)), frame.plot = FALSE, ## flld.c+ plot.axes = {}) demo(persp) ## ## ## demo(persp) ## ---- ~~~~~ ## ## &gt; ### Demos for persp() plots -- things not in example(persp) ## &gt; ### ------------------------- ## &gt; ## &gt; require(datasets) ## ## &gt; require(grDevices); require(graphics) ## ## &gt; ## (1) The Obligatory Mathematical surface. ## &gt; ## Rotated sinc function. ## &gt; ## &gt; x &lt;- seq(-10, 10, length.out = 50) ## ## &gt; y &lt;- x ## ## &gt; rotsinc &lt;- function(x,y) ## + { ## + sinc &lt;- function(x) { y &lt;- sin(x)/x ; y[is.na(y)] &lt;- 1; y } ## + 10 * sinc( sqrt(x^2+y^2) ) ## + } ## ## &gt; sinc.exp &lt;- expression(z == Sinc(sqrt(x^2 + y^2))) ## ## &gt; z &lt;- outer(x, y, rotsinc) ## ## &gt; oldpar &lt;- par(bg = &quot;white&quot;) ## ## &gt; persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = &quot;lightblue&quot;) ## ## &gt; title(sub=&quot;.&quot;)## work around persp+plotmath bug ## ## &gt; title(main = sinc.exp) ## ## &gt; persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = &quot;lightblue&quot;, ## + ltheta = 120, shade = 0.75, ticktype = &quot;detailed&quot;, ## + xlab = &quot;X&quot;, ylab = &quot;Y&quot;, zlab = &quot;Z&quot;) ## ## &gt; title(sub=&quot;.&quot;)## work around persp+plotmath bug ## ## &gt; title(main = sinc.exp) ## ## &gt; ## (2) Visualizing a simple DEM model ## &gt; ## &gt; z &lt;- 2 * volcano # Exaggerate the relief ## ## &gt; x &lt;- 10 * (1:nrow(z)) # 10 meter spacing (S to N) ## ## &gt; y &lt;- 10 * (1:ncol(z)) # 10 meter spacing (E to W) ## ## &gt; persp(x, y, z, theta = 120, phi = 15, scale = FALSE, axes = FALSE) ## ## &gt; ## (3) Now something more complex ## &gt; ## We border the surface, to make it more &quot;slice like&quot; ## &gt; ## and color the top and sides of the surface differently. ## &gt; ## &gt; z0 &lt;- min(z) - 20 ## ## &gt; z &lt;- rbind(z0, cbind(z0, z, z0), z0) ## ## &gt; x &lt;- c(min(x) - 1e-10, x, max(x) + 1e-10) ## ## &gt; y &lt;- c(min(y) - 1e-10, y, max(y) + 1e-10) ## ## &gt; fill &lt;- matrix(&quot;green3&quot;, nrow = nrow(z)-1, ncol = ncol(z)-1) ## ## &gt; fill[ , i2 &lt;- c(1,ncol(fill))] &lt;- &quot;gray&quot; ## ## &gt; fill[i1 &lt;- c(1,nrow(fill)) , ] &lt;- &quot;gray&quot; ## ## &gt; par(bg = &quot;lightblue&quot;) ## ## &gt; persp(x, y, z, theta = 120, phi = 15, col = fill, scale = FALSE, axes = FALSE) ## ## &gt; title(main = &quot;Maunga Whau\\nOne of 50 Volcanoes in the Auckland Region.&quot;, ## + font.main = 4) ## ## &gt; par(bg = &quot;slategray&quot;) ## ## &gt; persp(x, y, z, theta = 135, phi = 30, col = fill, scale = FALSE, ## + ltheta = -120, lphi = 15, shade = 0.65, axes = FALSE) ## ## &gt; ## Don&#39;t draw the grid lines : border = NA ## &gt; persp(x, y, z, theta = 135, phi = 30, col = &quot;green3&quot;, scale = FALSE, ## + ltheta = -120, shade = 0.75, border = NA, box = FALSE) ## ## &gt; ## `color gradient in the soil&#39; : ## &gt; fcol &lt;- fill ; fcol[] &lt;- terrain.colors(nrow(fcol)) ## ## &gt; persp(x, y, z, theta = 135, phi = 30, col = fcol, scale = FALSE, ## + ltheta = -120, shade = 0.3, border = NA, box = FALSE) ## ## &gt; ## `image like&#39; colors on top : ## &gt; fcol &lt;- fill ## ## &gt; zi &lt;- volcano[ -1,-1] + volcano[ -1,-61] + ## + volcano[-87,-1] + volcano[-87,-61] ## / 4 ## ## &gt; fcol[-i1,-i2] &lt;- ## + terrain.colors(20)[cut(zi, ## + stats::quantile(zi, seq(0,1, length.out = 21)), ## + include.lowest = TRUE)] ## ## &gt; persp(x, y, 2*z, theta = 110, phi = 40, col = fcol, scale = FALSE, ## + ltheta = -120, shade = 0.4, border = NA, box = FALSE) ## ## &gt; ## reset par(): ## &gt; par(oldpar) demo(graphics) ## ## ## demo(graphics) ## ---- ~~~~~~~~ ## ## &gt; # Copyright (C) 1997-2009 The R Core Team ## &gt; ## &gt; require(datasets) ## ## &gt; require(grDevices); require(graphics) ## ## &gt; ## Here is some code which illustrates some of the differences between ## &gt; ## R and S graphics capabilities. Note that colors are generally specified ## &gt; ## by a character string name (taken from the X11 rgb.txt file) and that line ## &gt; ## textures are given similarly. The parameter &quot;bg&quot; sets the background ## &gt; ## parameter for the plot and there is also an &quot;fg&quot; parameter which sets ## &gt; ## the foreground color. ## &gt; ## &gt; ## &gt; x &lt;- stats::rnorm(50) ## ## &gt; opar &lt;- par(bg = &quot;white&quot;) ## ## &gt; plot(x, ann = FALSE, type = &quot;n&quot;) ## ## &gt; abline(h = 0, col = gray(.90)) ## ## &gt; lines(x, col = &quot;green4&quot;, lty = &quot;dotted&quot;) ## ## &gt; points(x, bg = &quot;limegreen&quot;, pch = 21) ## ## &gt; title(main = &quot;Simple Use of Color In a Plot&quot;, ## + xlab = &quot;Just a Whisper of a Label&quot;, ## + col.main = &quot;blue&quot;, col.lab = gray(.8), ## + cex.main = 1.2, cex.lab = 1.0, font.main = 4, font.lab = 3) ## ## &gt; ## A little color wheel. This code just plots equally spaced hues in ## &gt; ## a pie chart. If you have a cheap SVGA monitor (like me) you will ## &gt; ## probably find that numerically equispaced does not mean visually ## &gt; ## equispaced. On my display at home, these colors tend to cluster at ## &gt; ## the RGB primaries. On the other hand on the SGI Indy at work the ## &gt; ## effect is near perfect. ## &gt; ## &gt; par(bg = &quot;gray&quot;) ## ## &gt; pie(rep(1,24), col = rainbow(24), radius = 0.9) ## ## &gt; title(main = &quot;A Sample Color Wheel&quot;, cex.main = 1.4, font.main = 3) ## ## &gt; title(xlab = &quot;(Use this as a test of monitor linearity)&quot;, ## + cex.lab = 0.8, font.lab = 3) ## ## &gt; ## We have already confessed to having these. This is just showing off X11 ## &gt; ## color names (and the example (from the postscript manual) is pretty &quot;cute&quot;. ## &gt; ## &gt; pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12) ## ## &gt; names(pie.sales) &lt;- c(&quot;Blueberry&quot;, &quot;Cherry&quot;, ## + &quot;Apple&quot;, &quot;Boston Cream&quot;, &quot;Other&quot;, &quot;Vanilla Cream&quot;) ## ## &gt; pie(pie.sales, ## + col = c(&quot;purple&quot;,&quot;violetred1&quot;,&quot;green3&quot;,&quot;cornsilk&quot;,&quot;cyan&quot;,&quot;white&quot;)) ## ## &gt; title(main = &quot;January Pie Sales&quot;, cex.main = 1.8, font.main = 1) ## ## &gt; title(xlab = &quot;(Don&#39;t try this at home kids)&quot;, cex.lab = 0.8, font.lab = 3) ## ## &gt; ## Boxplots: I couldn&#39;t resist the capability for filling the &quot;box&quot;. ## &gt; ## The use of color seems like a useful addition, it focuses attention ## &gt; ## on the central bulk of the data. ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; n &lt;- 10 ## ## &gt; g &lt;- gl(n, 100, n*100) ## ## &gt; x &lt;- rnorm(n*100) + sqrt(as.numeric(g)) ## ## &gt; boxplot(split(x,g), col=&quot;lavender&quot;, notch=TRUE) ## ## &gt; title(main=&quot;Notched Boxplots&quot;, xlab=&quot;Group&quot;, font.main=4, font.lab=1) ## ## &gt; ## An example showing how to fill between curves. ## &gt; ## &gt; par(bg=&quot;white&quot;) ## ## &gt; n &lt;- 100 ## ## &gt; x &lt;- c(0,cumsum(rnorm(n))) ## ## &gt; y &lt;- c(0,cumsum(rnorm(n))) ## ## &gt; xx &lt;- c(0:n, n:0) ## ## &gt; yy &lt;- c(x, rev(y)) ## ## &gt; plot(xx, yy, type=&quot;n&quot;, xlab=&quot;Time&quot;, ylab=&quot;Distance&quot;) ## ## &gt; polygon(xx, yy, col=&quot;gray&quot;) ## ## &gt; title(&quot;Distance Between Brownian Motions&quot;) ## ## &gt; ## Colored plot margins, axis labels and titles. You do need to be ## &gt; ## careful with these kinds of effects. It&#39;s easy to go completely ## &gt; ## over the top and you can end up with your lunch all over the keyboard. ## &gt; ## On the other hand, my market research clients love it. ## &gt; ## &gt; x &lt;- c(0.00, 0.40, 0.86, 0.85, 0.69, 0.48, 0.54, 1.09, 1.11, 1.73, 2.05, 2.02) ## ## &gt; par(bg=&quot;lightgray&quot;) ## ## &gt; plot(x, type=&quot;n&quot;, axes=FALSE, ann=FALSE) ## ## &gt; usr &lt;- par(&quot;usr&quot;) ## ## &gt; rect(usr[1], usr[3], usr[2], usr[4], col=&quot;cornsilk&quot;, border=&quot;black&quot;) ## ## &gt; lines(x, col=&quot;blue&quot;) ## ## &gt; points(x, pch=21, bg=&quot;lightcyan&quot;, cex=1.25) ## ## &gt; axis(2, col.axis=&quot;blue&quot;, las=1) ## ## &gt; axis(1, at=1:12, lab=month.abb, col.axis=&quot;blue&quot;) ## ## &gt; box() ## ## &gt; title(main= &quot;The Level of Interest in R&quot;, font.main=4, col.main=&quot;red&quot;) ## ## &gt; title(xlab= &quot;1996&quot;, col.lab=&quot;red&quot;) ## ## &gt; ## A filled histogram, showing how to change the font used for the ## &gt; ## main title without changing the other annotation. ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; x &lt;- rnorm(1000) ## ## &gt; hist(x, xlim=range(-4, 4, x), col=&quot;lavender&quot;, main=&quot;&quot;) ## ## &gt; title(main=&quot;1000 Normal Random Variates&quot;, font.main=3) ## ## &gt; ## A scatterplot matrix ## &gt; ## The good old Iris data (yet again) ## &gt; ## &gt; pairs(iris[1:4], main=&quot;Edgar Anderson&#39;s Iris Data&quot;, font.main=4, pch=19) ## ## &gt; pairs(iris[1:4], main=&quot;Edgar Anderson&#39;s Iris Data&quot;, pch=21, ## + bg = c(&quot;red&quot;, &quot;green3&quot;, &quot;blue&quot;)[unclass(iris$Species)]) ## ## &gt; ## Contour plotting ## &gt; ## This produces a topographic map of one of Auckland&#39;s many volcanic &quot;peaks&quot;. ## &gt; ## &gt; x &lt;- 10*1:nrow(volcano) ## ## &gt; y &lt;- 10*1:ncol(volcano) ## ## &gt; lev &lt;- pretty(range(volcano), 10) ## ## &gt; par(bg = &quot;lightcyan&quot;) ## ## &gt; pin &lt;- par(&quot;pin&quot;) ## ## &gt; xdelta &lt;- diff(range(x)) ## ## &gt; ydelta &lt;- diff(range(y)) ## ## &gt; xscale &lt;- pin[1]/xdelta ## ## &gt; yscale &lt;- pin[2]/ydelta ## ## &gt; scale &lt;- min(xscale, yscale) ## ## &gt; xadd &lt;- 0.5*(pin[1]/scale - xdelta) ## ## &gt; yadd &lt;- 0.5*(pin[2]/scale - ydelta) ## ## &gt; plot(numeric(0), numeric(0), ## + xlim = range(x)+c(-1,1)*xadd, ylim = range(y)+c(-1,1)*yadd, ## + type = &quot;n&quot;, ann = FALSE) ## ## &gt; usr &lt;- par(&quot;usr&quot;) ## ## &gt; rect(usr[1], usr[3], usr[2], usr[4], col=&quot;green3&quot;) ## ## &gt; contour(x, y, volcano, levels = lev, col=&quot;yellow&quot;, lty=&quot;solid&quot;, add=TRUE) ## ## &gt; box() ## ## &gt; title(&quot;A Topographic Map of Maunga Whau&quot;, font= 4) ## ## &gt; title(xlab = &quot;Meters North&quot;, ylab = &quot;Meters West&quot;, font= 3) ## ## &gt; mtext(&quot;10 Meter Contour Spacing&quot;, side=3, line=0.35, outer=FALSE, ## + at = mean(par(&quot;usr&quot;)[1:2]), cex=0.7, font=3) ## ## &gt; ## Conditioning plots ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; coplot(lat ~ long | depth, data = quakes, pch = 21, bg = &quot;green3&quot;) ## ## &gt; par(opar) 5.2 Entrada de dados Nesse tópico utlizaremos o arquivo de dados dadosfisio.csv. Dados fisico hidrico de 3 solos com textutas diferentes. Cod. Solo Areia Silte Argila Z1 NITOSSOLO 122 121 757 Z2 LATOSSOLO 710 80 210 Z3 LATOSSOLO 892 10 98 Ler dados via web. solo &lt;- read.table(&quot;https://www.dropbox.com/s/zg7fyg1iewtji49/dadosfisio.csv?dl=1&quot;, sep = &quot;;&quot;, header = T, dec = &quot;,&quot;) Verificar a estrutura de dados. str(solo) ## &#39;data.frame&#39;: 108 obs. of 16 variables: ## $ z : int 1 1 1 1 1 1 1 1 1 1 ... ## $ x : int 1 1 1 1 1 1 3 3 3 3 ... ## $ y : int 1 3 5 7 9 11 1 3 5 7 ... ## $ cota : num 9.15 8.95 8.78 8.59 8.48 8.41 8.93 8.76 8.58 8.48 ... ## $ ds : num 1.5 1.47 1.47 1.39 1.38 ... ## $ cc : num 0.398 0.382 0.351 0.372 0.356 ... ## $ ma : num 0.129 0.153 0.185 0.188 0.208 ... ## $ ptotal: num 0.526 0.535 0.537 0.561 0.564 ... ## $ tibo : num 46.1 19.2 172.8 96 30.7 ... ## $ tibe : num 26.8 26.1 113.9 74.8 37.2 ... ## $ a : num 926 384 275 1207 151 ... ## $ b : num -0.529 -0.418 -0.131 -0.376 -0.227 ... ## $ X3 : num 518 243 238 798 118 ... ## $ X60 : num 153.2 92.7 176.5 335.4 69.9 ... ## $ X90 : num 106.2 69.4 161.2 258.4 59.8 ... ## $ X120 : num 73.6 52 147.2 199 51.1 ... Resumo estatástico da coluna 5 a coluna 8 de todos os solos summary(solo[5:8]) ## ds cc ma ptotal ## Min. :1.263 Min. :0.1501 Min. :0.004834 Min. :0.2257 ## 1st Qu.:1.500 1st Qu.:0.2505 1st Qu.:0.047689 1st Qu.:0.3090 ## Median :1.722 Median :0.2712 Median :0.081510 Median :0.3284 ## Mean :1.660 Mean :0.2998 Mean :0.090675 Mean :0.3905 ## 3rd Qu.:1.787 3rd Qu.:0.3579 3rd Qu.:0.129955 3rd Qu.:0.5269 ## Max. :1.960 Max. :0.4997 Max. :0.238551 Max. :0.6015 Neste exemplo vamos analisar cada solo separadamente usando o comando subset() solo1 &lt;- subset(solo, z==1) solo2 &lt;- subset(solo, z==2) solo3 &lt;- subset(solo, z==3) 5.3 Usando a função plot() A função plot() inicia um novo gráfico. Em sua forma mais simples a função recebe valores de coordenadas ds (densidade do solo) e ptotal (porosidade total do solo) do solo z1. plot(solo1$ds,solo1$ptotal) Vamos no gráfico inserir linhas ligando os pontos. Use o argumento *type=“l” na função plot() plot(solo1$ds,solo1$ptotal, type = &quot;l&quot;) Verifique outras opcões para os gráfico type = “p” especifica o tipo de plotagem “p”: pontos, “l”: linhas, “b”: pontos conectados por linhas, “o”: id. mas as linhas estão acima dos pontos, “h”: linhas verticais, “s”: passos, os dados são representados pelo topo das linhas verticais, “S”: id. mas os dados são representados pela parte inferior das linhas verticais x &lt;- 0:12 y &lt;- sin(pi/5 * x) op &lt;- par(mfrow = c(3,3), mar = .1+ c(2,2,3,1)) for (tp in c(&quot;p&quot;,&quot;l&quot;,&quot;b&quot;, &quot;c&quot;,&quot;o&quot;,&quot;h&quot;, &quot;s&quot;,&quot;S&quot;,&quot;n&quot;)) { plot(y ~ x, type = tp, main = paste0(&quot;plot(*, type = \\&quot;&quot;, tp, &quot;\\&quot;)&quot;)) if(tp == &quot;S&quot;) { lines(x, y, type = &quot;s&quot;, col = &quot;red&quot;, lty = 2) mtext(&quot;lines(*, type = \\&quot;s\\&quot;, ...)&quot;, col = &quot;red&quot;, cex = 0.8) } } par(op) 5.3.1 Mudando o padrão dos pontos pch= Pode-se usar diferentes padrões para os pontos usando o argumento pch=.Diferentes tipos de símbolos são associados a diferentes números. Pode-se ainda usar caracteres como o simbolo desejado. Use a opção pch = para especificar simbolos a serem usados ao traçar pontos. Para os simbolos de 21 a 25, especifique a cor da borda (col =). plot(solo1$ds,solo1$ptotal, pch=21, ylim = c(0,0.6), xlim = c(1,2)) plot(solo2$ds,solo2$ptotal,pch=2, col=&quot;blue&quot;) plot(solo3$ds,solo3$ptotal,pch=&quot;%&quot;) Neste exemplo acima note, que foi adicionado o argumento ylim e xlim eles limitam os valores minimos e maximos: xlim=c(xmin, xmax) ylim=c(ymin, ymax)) Veja um exemplo do padrão dos pontos. plot (0:20, #coord. eixo X rep (0,21), #coord. eixo y pch = 0:20, #padrão dos pontos variando cex = 2, #tamanho dos pontos main = &quot;Padrão dos pontos&quot;, #Titulo (note o \\n) xlab = &quot;pch = &quot;, #texto do eixo de x ylab = &quot;&quot;) #texto do eixo de y 5.3.2 Mudando as linhas (lwd e lty) Você pode alterar linhas usando as seguintes opções. Isso é particularmente útil para linhas de referência, eixos e linhas de ajuste. A largura das linhas pode ser mudada com o argumento lwd=, enquanto os estilos das linhas podem ser modificados com o argumento lty=. plot(solo3$ds,solo3$ptotal, lwd=2) # linha grossa plot(solo2$ds,solo2$ptotal, lty=2) #linha interrompida x &lt;- 1:9 y &lt;- 1:9 plot(x, y, type = &quot;n&quot;) lines(c(2, 8), c(8, 8), lwd = 2) lines(c(2, 8), c(7, 7), lty = 2, lwd = 2) lines(c(2, 8), c(6, 6), lty = 3, lwd = 2) lines(c(2, 8), c(5, 5), lty = 4, lwd = 2) lines(c(2, 8), c(4, 4), lty = 5, lwd = 2) lines(c(2, 8), c(3, 3), lty = 6, lwd = 2) 5.3.3 Adicionando linhas a um grafico de pontos A função utilizada para inserir linhas é abline(). Vamos usar a função abline para inserir uma linha que mostra a média dos dados do eixo Y. o h é de linha horizontal. Fará uma linha na horizontal que passa pela média de y. plot(solo3$ds,solo3$ptotal, abline(h=mean(solo3$ptotal))) Para passar uma linha que passa pela média de x plot(solo3$ds,solo3$ptotal) plot(solo3$ds,solo3$ptotal, abline(v=mean(solo3$ds))) ## o v é de vertical Também é possível inserir as duas linhas ao mesmo tempo. plot(solo3$ds,solo3$ptotal, abline(h=mean(solo3$ptotal), v=mean(solo3$ds),col=&quot;red&quot;)) Com cores diferentes plot(solo3$ds,solo3$ptotal, abline(h=mean(solo3$ptotal), v=mean(solo3$ds),col=c(2,4))) 5.3.4 Definindo o intervalo dos eixos Se você quiser preencher um mesmo gráfico com linhas e pontos que possuem diferentes amplitudes como nosso exemplo do solos, deve usar o argumento type=n. Com este argumento um gráfico em branco é criado. plot(c(1.55,2),c(0,0.6),type=&#39;n&#39;) points(solo3$ds,solo3$ptotal, pch=2) points(solo2$ds,solo2$ptotal) 5.3.5 Personalizando os gráficos Alguns parâmetros podem ser usados no intuito de personalizar um gráfico no R. Exemplo: plot(solo1$ptotal,solo1$ds) plot(solo1$ptotal,solo1$ds, #plota ds e ptotal xlab=&quot;Macroporosdiade (%)&quot;, #nomeia o eixo x ylab=expression(Ds~(mg~Kg^{-1})), #nomeia o eixo y main=&quot;Como personalizar um gráfico&quot;, #referente ao título xlim=c(0.48,0.64), #limites do eixo x ylim=c(0,2), col=&quot;red&quot;, #limites do eixo y pch=22, #padrão dos pontos bg=&quot;yellow&quot;, #cor de preenchimento tcl=0.4, #tamanho dos traços dos eixos las=1, #orientação do texto em y cex=1.5, #tamanho do objeto do ponto bty=&quot;l&quot;, #altera as bordas abline(lm(solo1$ds~solo1$ptotal))) #regressao dos pontos Veja o demo(plotmath) para saber mais sobre anotações em gráficos. 5.4 Histogramas A função hist() produz um histograma dos dados informados em seu argumento enquanto a função barplot() produz um gráfico de barras. hist(solo1$ds) rug(solo1$ds) 5.4.1 Personalizando gráficos Os histogramas criados no R seguem um certo padrão (conhecido como parâmetros default) que podem ser alterados de acordo com a preferência do usuário. Você pode obter informações detalhadas desses parâmetros se usar os recursos de ajuda do R. hist(solo1$ds, #histograma de ds main=&quot;Histograma Personalizado\\ndensidade do solo&quot;,#título xlab=expression(Ds~(mg~Kg^{-1})), #texto do eixo das abscissas ylab=&quot;Probabilidades&quot;, #texto do eixo das ordenadas xlim=c(1,2), #limites do eixo de x ylim=c(0,10), #limites do eixo y col=&quot;lightblue&quot;, #cor das colunas border=&quot;white&quot;, #cor das bordas das colunas adj=0, #alinhamento dos textos 0, 0.5 e 1 col.axis=&quot;red&quot;) #cor do texto nos eixos 5.5 Gráficos de Barras Assemelha-se ao histograma, Porém, nesse caso, os dados referem-se a categoria ou aos tratamentos barplot(solo$ptotal,names.arg=solo$z, horiz = T) 5.6 Boxplots Dados de um experimento visando controle de pulgão (Aphis gossypii Glover) em cultura de pepino, instalado em delineamento inteiramente casualizado com 6 repetições. A resposta observada foi o número de pulgões após a aplicação de produtos indicados para seu controle. dados &lt;- read.table(&quot;https://www.dropbox.com/s/jjyo8dhyy0qt3ft/BanzattoQd3.2.1.txt?dl=1&quot;) str(dados) ## &#39;data.frame&#39;: 30 obs. of 3 variables: ## $ trat : Factor w/ 5 levels &quot;Azinfos etilico&quot;,..: 5 1 3 4 2 5 1 3 4 2 ... ## $ rept : int 1 1 1 1 1 2 2 2 2 2 ... ## $ pulgoes: int 2370 1282 562 173 193 1687 1527 321 127 71 ... trat Fator de níveis nominais. Tratamento aplicado para controle do pulgão. rept Número inteiro que identifica as repetições de cada tratamento. pulgões Número de pulgões coletados 36 horas após a pulverização dos tratamentos. Boxplots podem ser criados para variáveis individuais ou para variáveis por grupo. O formato é boxplot ( x , data =) , em que x é uma fórmula e data = denota o quadro de dados que fornece os dados. Um exemplo de uma fórmula é y ~ group onde um boxplot separado para a variável numérica é gerado para cada valor de group. x11() boxplot(pulgoes~trat, #formula do boxplot data = dados, #conjunto de dados main=&quot;boxplot&quot;, #título xlab=&quot;Controle do pulgão&quot;, #texto do eixo x ylab=&quot;Numero de plugões&quot;, #texto do eixo y col=3) #cor verde Adicione horizontal = TRUE para inverter a orientação do eixo. boxplot(pulgoes~trat, #formula do boxplot data = dados, #conjunto de dados main=&quot;boxplot&quot;, #t?tulo xlab=&quot;Controle do pulgão&quot;, #texto do eixo x ylab=&quot;Numero de plugões&quot;, #texto do eixo y col=3, horizontal = T, #cor verde notch=T) #teste para mediana ## Warning in bxp(list(stats = structure(c(825, 871, 972.5, 1282, 1527, 44, : some ## notches went outside hinges (&#39;box&#39;): maybe set notch=FALSE 5.6.1 Boxplot com fatorial Boxplot com 2 fatores, com caixas coloridas para facilitar a interpretação. Efeito de Recipientes para duas Espécies de Eucalipto Experimento em esquema fatorial 3x2 para estudar o efeito de 3 tipos de recipientes para a produção de mudas de duas espécies de Eucalipto. O experimento foi instalado em delineamento inteiramente casualizado. recipie São os níveis de recipiente estudados: - SPP - saco plástico pequeno; - SPG - saco plástico grande; e - Lam - laminado. especie São as espécies de Eucalipto: Eucalyptus citriodora e Eucalyptus grandis rept Identifica as repetições de cada combinação dos fatores recipiente e espécie. alt Altura das mudas aos 80 dias de idade (cm). Baixar dados via web. fat &lt;- read.table(&quot;https://www.dropbox.com/s/sahc5n80rlkcfx4/BanzattoQd5.2.4.txt?dl=1&quot;) str(fat) ## &#39;data.frame&#39;: 24 obs. of 4 variables: ## $ recipie: Factor w/ 3 levels &quot;Lam&quot;,&quot;SPG&quot;,&quot;SPP&quot;: 3 3 2 2 1 1 3 3 2 2 ... ## $ especie: Factor w/ 2 levels &quot;E. citriodora&quot;,..: 1 2 1 2 1 2 1 2 1 2 ... ## $ rept : int 1 1 1 1 1 1 2 2 2 2 ... ## $ alt : num 26.2 24.8 25.7 19.6 22.8 19.8 26 24.6 26.3 21.1 ... Gerar o gráfico boxpolt com o comando abaixo. boxplot(fat$alt~fat$recipie*especie, data=fat, notch=F, col=(c(&quot;gold&quot;,&quot;darkgreen&quot;,&quot;brown&quot;)), main=&quot;Fatorial&quot;, xlab=&quot;Recipiente e Espécies&quot;, ylab=&quot;Altura de plantas (cm)&quot;) 5.7 Cores Gráficos em preto e branco são bons na maioria dos casos, mas cores podem ser mudadas usando col=\"red\" (escrevendo o nome da cor) ou col=2 (usando números). O comando abaixo mostra os números que especificam algumas cores. pie(rep(1,30),col=rainbow(30)) Veja sua tabela de cores executando o script paletedecores.R. Podemos também criar cores personalizadas usando a função do rgb(), que recebe como argumentos as quantidades de vermelho (red), verde (green) e azul (blue) e, opcionalmente, o grau de opacidade (alpha). Os valores devem ser números reais entre 0 e 1. Exemplos: goiaba &lt;- rgb(0.94, 0.41, 0.40) goiaba.semitrans &lt;- rgb(0.94, 0.41, 0.40, alpha = 0.5) vitamina &lt;- rgb(red = c(0.87, 0.70), green = c(0.83, 0.77), blue = c(0.71, 0.30), names = c(&quot;leite&quot;, &quot;abacate&quot;)) 5.8 Interagindo com a Janela gráfica Poderemos com o mouse marcar o ponte desejado usando a função identify () plot(solo1$ds~solo1$ptotal) identify(solo1$ds,n=1) ## integer(0) 5.9 Texto e tamanho do símbolo As seguintes opções podem ser usadas para controlar o tamanho do texto e do símbolo em gráficos. cex número que indica o valor pelo qual o texto e os símbolos de plotagem devem ser dimensionados em relação ao padrão. 1 = padrão, 1,5 é 50% maior, 0,5 é 50% menor, etc. 5.10 Visualizar vários gráficos x11() boxplot(pulgoes~trat, #formula do boxplot data = dados, #conjunto de dados main=&quot;boxplot&quot;, #título xlab=&quot;Controle do pulgão&quot;, #texto do eixo x ylab=&quot;Numero de plugões&quot;, #texto do eixo y col=3, #cor verde notch=F) #teste para mediana 5.10.1 Varios gráficos na mesma janela gráfica Você pode dar instruções para o programa mostrar diversos gráficos pequenos em uma mesma janela ao invês de um apenas. Para isto use a função par(). Exemplo 1 par(mfrow = c(2,2)) #2 linhas e 2 colunas plot(solo1$ptotal,solo1$ds) boxplot(solo1$ds,solo2$ds, solo3$ds) hist(solo$ptotal) plot(solo$ptotal,solo$ds) Exemplo 2 par(mfrow = c(2,3)) pairs(solo) hist(solo$ds) plot(solo$ds, col=solo$z) plot(density(solo$ds)) 5.11 Salvando gráficos Você pode salvar o gráfico em vários formatos no menu Arquivo -&gt; Salvar como. Você também pode salvar o gráfico via código usando uma das seguintes funções. pdf (file = \"meugráfico.pdf\") #ficheiro PDF win.metafile (\"meu grafico.wmf\") #metarquivo do windows png (\"meu grafico.png\") #arquivo png jpeg (\"meu grafico.jpg\") #arquivo jpeg bmp (\"meu grafico.bmp\") #arquivo bmp postscript (\"meu grafico.ps\") #arquivo postscript "],
["gráficos-com-ggplot2.html", " 6 Gráficos com ggplot2 6.1 Personalizando os gráficos 6.2 Exemplos 6.3 Referência", " 6 Gráficos com ggplot2 Existem muitas maneiras de fazer Gráficos em R, cada um com suas vantagens e desvantagens. O foco aqui está no pacote ggplot2, que é baseado na Grammar of Graphics (Gramática dos Gráficos) para descrever os gráficos de dados. Utilize o codigo abaixo para instalar o pacote ggplot2 install.packages(&quot;ggplot2&quot;) Sempre carregue o pacote antes de utilizá-lo. library(ggplot2) Utilizaremos o banco de dados: dadosfisio Baixar os dados fisio &lt;- read.csv2(&quot;https://www.dropbox.com/s/zg7fyg1iewtji49/dadosfisio.csv?dl=1&quot;) Veja as primeiras linhas. head(fisio) ## z x y cota ds cc ma ptotal tibo tibe a ## 1 1 1 1 9.15 1.501258 0.3975615 0.1288555 0.5264170 46.08 26.78 926.3955 ## 2 1 1 3 8.95 1.474362 0.3818767 0.1530250 0.5349017 19.20 26.10 383.8130 ## 3 1 1 5 8.78 1.469118 0.3514075 0.1851484 0.5365559 172.80 113.92 275.3272 ## 4 1 1 7 8.59 1.392845 0.3724094 0.1882073 0.5606167 96.00 74.83 1206.7585 ## 5 1 1 9 8.48 1.383309 0.3559554 0.2076696 0.5636250 30.72 37.20 151.4032 ## 6 1 1 11 8.41 1.417010 0.3144429 0.2385509 0.5529937 151.32 124.52 368.7992 ## b X3 X60 X90 X120 ## 1 -0.5290035 518.0810 153.24778 106.20581 73.60416 ## 2 -0.4176008 242.5903 92.74121 69.43243 51.98188 ## 3 -0.1307566 238.4857 176.48417 161.19222 147.22529 ## 4 -0.3764298 798.0272 335.41915 258.38731 199.04648 ## 5 -0.2270424 117.9800 69.94649 59.76121 51.05906 ## 6 -0.1549382 311.0754 217.73464 195.56291 175.64890 O código abaixo é um exemplo de um gráfico bem simples, construído a partir das duas principais camadas. O eixo y representa a densidade do solo e ao eixo x a variavel capacidade de campo. ggplot(data = fisio, aes(x = ds, y = cc)) + geom_point() Aqui, essas formas geomótricas são pontos, selecionados pela função geom_point(), gerando, assim, um gráfico de dispersão. A função aes() vem da palavra Aesthetics define a relação entre os dados e cada aspecto visual do gráfico, como qual variavel será representada no eixo x, qual será representada no eixo y, a cor e o tamanho dos componentes com a função colour. Outro aspecto que pode ser mapeado nesse gráfico é a cor dos pontos. ggplot(data = fisio, aes(x = ds, y = cc, colour = as.factor(z))) + geom_point() Agora, a variável z (classe de solo) foi mapeada a cor dos pontos, sendo que pontos vermelhos correspondem ao Nitossolo (valor 1) e pontos azuis e verdes os Latossolos. Observe que inserimos a variável z como um fator, pois temos interesse apenas nos valores “1”, “2” e “3”. No entanto, tambem podemos mapear uma variável contínua a cor dos pontos: ggplot(data = fisio, aes(x = ds, y = cc, colour = ptotal)) + geom_point() A porosidade do solo (ptotal), é representado pela tonalidade da cor azul. Também podemos mapear o tamanho dos pontos a uma variável de interesse. ggplot(data = fisio, aes(x = ds, y = cc, colour = ptotal, size = ma)) + geom_point() Outros geoms bastante utilizados: geom_line: para retas definidas por pares (x,y) geom_abline: para retas definidas por um intercepto e uma inclinação geom_hline: para retas horizontais geom_boxplot: para boxplots geom_histogram: para histogramas geom_density: para densidades geom_area: para áreas geom_bar: para barras Veja a seguir como é fácil gerar diversos Gráficos diferentes utilizando a mesma estrutura do gráfico de dispersão acima: ggplot(data = fisio, aes(x = factor(z), y = ds)) + geom_boxplot() gra &lt;- ggplot(data = fisio, aes(x = ds)) gra + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. gra + geom_histogram(binwidth=.05, colour=&quot;black&quot;, fill=&quot;white&quot;) gra + geom_density() + geom_histogram (aes(y=..density..), binwidth=.05, colour=&quot;black&quot;, fill=&quot;white&quot;) + geom_density(alpha=.2, fill=&quot;#FF6666&quot;) Exemplo Baixar dados via web. dados &lt;- read.table(&quot;https://www.dropbox.com/s/9woiye3ce9twp78/BanzattoQd4.5.2.txt?dl=1&quot;) Criar gráficos. bar &lt;- ggplot(data = dados, aes(y = peso, x = promalin, fill = factor(promalin))) Nestes exemplos, a altura da barra representará o valor em uma coluna do quadro de dados. Isso é feito usando stat=\"identity\" em vez do padrão stat=\"bin\". bar + geom_bar(stat=&quot;identity&quot;) Gráfico de barras agrupados bar + geom_bar(stat=&quot;identity&quot;, position=position_dodge()) Empilhado bar + geom_bar(stat=&quot;identity&quot;, colour =&quot;black&quot;) 6.1 Personalizando os gráficos 6.1.1 Cores O aspecto colour do boxplot, muda a cor do contorno. Para mudar o preenchimento, basta usar o fill. Usando colour ggplot(data = fisio, aes(x = factor(z), y = ds, colour = factor(z))) + geom_boxplot() Usando fill ggplot(data = fisio, aes(x = factor(z), y = ds, fill = factor(z))) + geom_boxplot() Mude a cor dos objetos sem atribuir a uma variavel. Para isso, observe que os aspectos colour e fill são especificados fora do aes(). ggplot(data = fisio, aes(x = factor(z), y = ds)) + geom_boxplot(colour = &quot;darkblue&quot;, fill= &quot;blue&quot;) 6.1.2 Eixos Para alterar os rotulos dos eixos acrescentamos as funções xlab() ou ylab(). box &lt;- ggplot(data = fisio, aes(x = factor(z), y = ds, fill = factor(z))) + geom_boxplot()+ xlab(&quot;Classes de solo&quot;) + ylab(expression(paste(Densidade~do~solo,&quot; g cm &quot;^{-3} ))) Alterar os limites dos Gráficos usamos as funções xlim() e ylim(). box + ylim (c(1.0,2.0)) Especifique marcas de escala diretamente box + coord_cartesian(ylim=c(1, 2)) + scale_y_continuous(breaks=seq(0, 2, 0.20)) Troque os eixos x e y box + coord_flip() Definir rótulos de marca de escala box2 &lt;- box + scale_x_discrete(breaks=c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), labels=c(&quot;Nitossolo&quot;,&quot;Latossolo&quot;, &quot;Latossolo&quot;)) 6.1.3 Legenda Remover legenda para uma estética específica (fill) box2 + guides(fill=FALSE) Também pode ser feito ao especificar a scale box2 + scale_fill_discrete(guide=FALSE) Isso remove todas as legendas box2 + theme(legend.position=&quot;none&quot;) Alterando a ordem dos itens na legenda box2 + scale_fill_discrete(breaks=c(&quot;2&quot;,&quot;3&quot;,&quot;1&quot;)) Modificando o texto de legenda de tétulos e rótulos box3 &lt;- box2 + scale_fill_discrete(name=&quot;Classes\\nde solo&quot;, breaks=c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), labels=c(&quot;CTI&quot;, &quot;FEI&quot;, &quot;IAPAR&quot;)) Modificando a aparência do título e dos rótulos da legenda # Título box3 + theme(legend.title = element_text(colour=&quot;black&quot;, size=13, face=&quot;bold&quot;)) # Níveis box3 + theme(legend.text = element_text(colour=&quot;black&quot;, size = 12, face = &quot;bold&quot;)) Modificando a caixa de legenda box3 + theme(legend.background = element_rect()) box3 + theme(legend.background = element_rect(fill=&quot;gray90&quot;)) Mudando a posição da legenda box3 + theme(legend.position=&quot;top&quot;) Posicione a legenda no gráfico, em que x, y é 0,0 (canto inferior esquerdo) a 1,1 (canto superior direito) box3 + theme(legend.position=c(.5, .5)) Defina o “ponto de ancoragem” da legenda (o canto inferior esquerdo é 0,0; o canto superior direito é 1,1) box3 + theme(legend.justification=c(0,0), legend.position=c(0,0)) Coloque o canto inferior direito da caixa de legenda no canto inferior direito do gráfico box3 + theme(legend.justification=c(1,0), legend.position=c(1,0)) 6.1.4 Título box3 + ggtitle(&quot;Variabilidade da densidade do solo\\n em diferentes solos&quot;) box3 + labs(title=&quot;Variabilidade da densidade do solo\\n em diferentes solos&quot;) 6.1.5 Facets Outra funcionalidade muito importante do ggplot2 é o uso de facets. Você quer dividir seus dados por uma ou mais variáveis e plotar os subconjuntos de dados juntos. ggplot(data = fisio, aes(x = ds, y = cc, colour = as.factor(z))) + geom_point() + facet_grid(z~.) Podemos colocar os graficos lado a lado também. ggplot(data = fisio, aes(x = ds, y = cc, colour = as.factor(z))) + geom_point() + facet_grid(.~z) 6.2 Exemplos 6.2.1 Regressão Efeito do Gesso no Peso de grãos de feijão Estudo sobre o efeito do gesso no peso de grãos de feijo (Phaseolus vulgaris L.) feito por Ragazzi (1979). O experimento foi instalado em delineamento inteiramente casualizado e foram estudados 7 n?veis de gesso, de 0 a 300, igualmente espaados em 50 kg ha-1. Baixar dados dados &lt;- read.table(&quot;https://www.dropbox.com/s/r6jz7mrktbgnbnx/BanzattoQd7.2.1.txt?dl=1&quot;) Verificar a estrutura dos dados str(dados) ## &#39;data.frame&#39;: 28 obs. of 3 variables: ## $ gesso: int 0 0 0 0 50 50 50 50 100 100 ... ## $ rept : int 1 2 3 4 1 2 3 4 1 2 ... ## $ peso : num 135 140 148 132 162 ... Analise de regressão model &lt;- lm( gesso ~ peso, dados) summary(model) ## ## Call: ## lm(formula = gesso ~ peso, data = dados) ## ## Residuals: ## Min 1Q Median 3Q Max ## -120.41 -70.79 -31.57 74.22 179.24 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -451.935 282.012 -1.603 0.121 ## peso 3.849 1.799 2.139 0.042 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 95.7 on 26 degrees of freedom ## Multiple R-squared: 0.1496, Adjusted R-squared: 0.1169 ## F-statistic: 4.575 on 1 and 26 DF, p-value: 0.04201 Extrair a equação do modelo eqn &lt;- as.character(as.expression(substitute(italic(y) == a + b * italic(x) * &quot;,&quot; ~~ italic(r)^2 ~ &quot;=&quot; ~ r2,list(a = format(coef(model)[1], digits=3),b = format(coef(model)[2], digits=3), r2 = format(summary(model)$r.squared, digits=3))))) Criando o gráfico ggplot(dados,aes(x=gesso,y=peso,color=peso)) + geom_point(size=2.9,shape=19, colour=&quot;grey10&quot;) + theme_bw(base_size = 10) + ylab(expression(paste( &quot;Peso (g)&quot; ))) + xlab(expression(paste(Gesso,&quot; kg ha&quot;^{-1} ))) + annotate(&quot;text&quot;, label=eqn, parse=TRUE, x=Inf, y=-Inf, hjust=1., vjust=-.5, size = 5) + stat_smooth(method = lm, se = T, colour=&quot;red&quot;, size=.85) ## `geom_smooth()` using formula &#39;y ~ x&#39; 6.2.2 Delineamento em blocos casualizados- DBC Efeito do Promalin sobre Furtos de Macieira Resultados de um experimento instalado na Fazenda Chapadão, no município de Angatuba - SP. O delineamento experimental foi o de blocos casualizados, sendo as parcelas constituídas de 4 plantas espaçadas de 6 x 7 metros, com 12 anos de idade na época da instalação do experimento. Baixar dados dados &lt;- read.table(&quot;https://www.dropbox.com/s/9woiye3ce9twp78/BanzattoQd4.5.2.txt?dl=1&quot;) Verificar Estrutura dos dados str(dados) ## &#39;data.frame&#39;: 20 obs. of 3 variables: ## $ promalin: Factor w/ 5 levels &quot;12.5&quot;,&quot;12.5+12.5&quot;,..: 1 3 4 2 5 1 3 4 2 5 ... ## $ bloco : Factor w/ 4 levels &quot;I&quot;,&quot;II&quot;,&quot;III&quot;,..: 1 1 1 1 1 2 2 2 2 2 ... ## $ peso : num 142 140 141 151 154 ... Transformação categorica dados$promalin = as.factor(dados$promalin) dados$bloco= as.factor(dados$bloco) Estatistísca descritiva summary(dados) ## promalin bloco peso ## 12.5 :4 I :5 Min. :130.6 ## 12.5+12.5 :4 II :5 1st Qu.:136.8 ## 25.0 :4 III:5 Median :141.6 ## 50.0 :4 IV :5 Mean :143.0 ## Testemunha:4 3rd Qu.:146.4 ## Max. :165.0 Ativar o pacote ggplot library(ggplot2) Fazer o gráfico ggplot(dados,aes(x=promalin ,y=peso, fill=promalin)) + geom_boxplot(size=0.55,shape=19, colour=&quot;black&quot;) + theme(legend.position=&quot;top&quot;) Analisando os blocos ggplot(dados,aes(x=promalin ,y=peso, fill=promalin)) + geom_point() + theme(legend.position=&quot;top&quot;) + facet_wrap(~bloco,ncol=4) Inserindo medias ggplot(dados,aes(x=promalin ,y=peso, fill=promalin)) + geom_boxplot(size=0.55,shape=19, colour=&quot;black&quot;) + theme(legend.position=&quot;top&quot;) + facet_wrap(~bloco,ncol=4) Inserindo legenda nos eixos ggplot(dados,aes(x=promalin,y=peso, fill=promalin)) + geom_boxplot(size=0.55,shape=19, colour=&quot;black&quot;) + theme(legend.position=&quot;top&quot;) + xlab(&quot;Tratamentos&quot;) + ylab(&quot;Peso médio dos frutos (g)&quot;) Inserindo legenda nos eixos ggplot(dados,aes(x=promalin ,y=peso, fill=promalin)) + geom_boxplot(size=0.55,shape=19, colour=&quot;black&quot;) + theme(legend.position=&quot;top&quot;) + stat_summary(fun.y=mean, geom=&quot;point&quot;,shape=1,size=2) + xlab(&quot;Tratamentos&quot;) + ylab(&quot;Peso médio dos frutos (g)&quot;) + theme(panel.grid.minor = element_line(colour = &quot;red&quot;, linetype = &quot;dotted&quot;)) ## Warning: `fun.y` is deprecated. Use `fun` instead. Inserindo tema_bw preto e branco ggplot(dados,aes(x=promalin ,y=peso, fill=promalin)) + geom_boxplot(size=0.55,shape=19, colour=&quot;black&quot;) + theme(legend.position=&quot;top&quot;) + stat_summary(fun.y=mean, geom=&quot;point&quot;,shape=1,size=2) + xlab(&quot;Tratamentos&quot;) + ylab(&quot;Peso médio dos frutos (g)&quot;) + theme_bw() ## Warning: `fun.y` is deprecated. Use `fun` instead. Inserindo legenda no topo ggplot(dados,aes(x=promalin ,y=peso, fill=promalin)) + geom_boxplot(size=0.55,shape=19, colour=&quot;black&quot;) + theme(legend.position=&quot;top&quot;) + stat_summary(fun.y=mean, geom=&quot;point&quot;,shape=1,size=2) + xlab(&quot;Tratamentos&quot;) + ylab(&quot;Peso médio dos frutos (g)&quot;) + theme_bw() + theme(legend.position=&quot;top&quot;) ## Warning: `fun.y` is deprecated. Use `fun` instead. Mudando escala do eixo y ggplot(dados,aes(x=promalin ,y=peso, fill=promalin)) + geom_boxplot(size=0.55,shape=19, colour=&quot;black&quot;) + theme(legend.position=&quot;top&quot;) + stat_summary(fun.y=mean, geom=&quot;point&quot;,shape=1,size=2) + xlab(&quot;Tratamentos&quot;) + ylab(&quot;Peso médio dos frutos (g)&quot;) + theme_bw() + theme(legend.position=&quot;top&quot;) + scale_y_continuous(breaks=seq(0, 180, 5)) + theme( axis.text.x = element_text(angle=90, vjust=0, size=10)) ## Warning: `fun.y` is deprecated. Use `fun` instead. 6.2.3 Dados Climáticos Dados climáticos de Rondonópolis - MT Baixar dados no banco de dados o arquivo roo.xlsx roo &lt;- read.csv2(&quot;https://www.dropbox.com/s/1ajoi1c8pla3yk6/roo.csv?dl=1&quot;) View(roo) str(roo) ## &#39;data.frame&#39;: 4337 obs. of 11 variables: ## $ dd : int 1 1 2 3 4 5 6 7 8 9 ... ## $ mm : int 1 2 2 2 2 2 2 2 2 2 ... ## $ ano : int 1998 1998 1998 1998 1998 1998 1998 1998 1998 1998 ... ## $ Prec : num NA 8.2 51 0.6 0 0 0 2.4 NA 0.8 ... ## $ Tmax : num 30 35.6 31.8 35.4 35.6 36.4 36.8 36.8 36.6 35.2 ... ## $ Tmin : num 21.7 21.8 21.8 21.5 22.1 22.5 23.5 23.5 24.3 22.9 ... ## $ n : num NA NA NA NA NA NA NA NA NA NA ... ## $ Tbs : num NA NA 25.1 25 26.6 ... ## $ Tbu : num NA NA 23.9 23 23.9 ... ## $ UR : num NA NA 89.8 86.5 80 ... ## $ Vvento: num NA NA 0.125 0.125 0.275 0.325 0.2 0.175 0.15 0.25 ... Boxplot para tempearatura minima ggplot(data = roo, aes(x = factor(mm),y = (Tmin)))+ geom_boxplot() + scale_x_discrete(breaks=c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;,&quot;12&quot;), labels=c(&quot;Jan&quot;,&quot;Fev&quot;, &quot;Mar&quot;, &quot;Abr&quot;, &quot;Mai&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Ago&quot;, &quot;Set&quot;, &quot;Out&quot;, &quot;Nov&quot;, &quot;Dez&quot;)) ## Warning: Removed 222 rows containing non-finite values (stat_boxplot). Grafico de distruição de temperatura minima total ggplot(data = roo, aes(x = (Tmin)))+ geom_density() ## Warning: Removed 222 rows containing non-finite values (stat_density). Grafico de distribuição de temperatura minima para cada mês ggplot(data = roo, aes(x = (Tmin), fill=factor(mm)))+ geom_density() ## Warning: Removed 222 rows containing non-finite values (stat_density). 6.3 Referência GROLEMUND, G. WICKHAM, H. R for Data Science Site: http://r4ds.had.co.nz/ SITE: https://www.statmethods.net/index.html CHANG, W. R Graphics Cookbook: Practical Recipes for Visualizing Data, Publisher: O’Reilly Media, 2002,416 p. Site: http://shop.oreilly.com/pesouct/0636920023135.do Este Capitulo foi baseado no livro Conhecendo o R: Um visão mais que estatística, e na página do Prof. Paulo Justiniando Ribeiro "],
["testes-estatísticos.html", " 7 Testes Estatísticos 7.1 Teste t de Student 7.2 Teste de variância 7.3 Teste para a normalidade - shapiro.test() 7.4 Teste U de Mann-Whitney 7.5 Covariância e Correlação 7.6 Outros testes", " 7 Testes Estatísticos O R inclui em sua gama de utilidades, uma poderosa ferramenta da estatástica contemporânea: os testes estatísticos. Dentre esses, podemos destacar os testes de media, amplamente usados em várias áreas do conhecimento. 7.1 Teste t de Student O teste t é bastante usado em várias situações do cotidiano quando se deseja fazer comparações entre uma ou mais médias, sejam elas dependentes ou não. Abaixo estão exemplos de vários modos de realizarmos o teste t. Dados referentes a temperatura média do ar em duas condições: dentro de uma casa de vegetação e no campo. pira_tem &lt;- read.csv2 (&quot;https://www.dropbox.com/s/zvp5iftcpb6bdpe/pira_tem.csv?dl=1&quot;, dec=&quot;.&quot;) str(pira_tem) ## &#39;data.frame&#39;: 768 obs. of 5 variables: ## $ hora : Factor w/ 96 levels &quot;0:00&quot;,&quot;0:15&quot;,..: 1 2 3 4 5 6 7 8 49 50 ... ## $ periodo: Factor w/ 4 levels &quot;equi_out&quot;,&quot;equi_prim&quot;,..: 4 4 4 4 4 4 4 4 4 4 ... ## $ local : Factor w/ 2 levels &quot;campo&quot;,&quot;estufa&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ temp : num 23.1 22.9 22.7 22.6 22.5 ... ## $ X : logi NA NA NA NA NA NA ... Apresentação dos dados em forma de gráfico library(ggplot2) ggplot(data= pira_tem, aes (x = hora, y = temp, colour =periodo)) + geom_point(size=2,shape=19) + geom_line() + facet_grid(.~local) + xlab(&quot;Horas&quot;) + ylab(&quot;Temperatura ºC&quot;) + ggtitle(&quot;Variação da temperatura mediana\\n nas quatro efemêrides&quot;) + theme(plot.title=element_text(face=&quot;bold&quot;, size=12, hjust = 0.5)) + theme_bw() ## geom_path: Each group consists of only one observation. Do you need to adjust ## the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust ## the group aesthetic? t.test() Realiza o teste t-Student para uma ou duas amostras. sintaxe: t.test(amostra1, amostra2, opções) Parâmetros amostra1: Vetor contendo a amostra da qual se quer testar a média populacional, ou comparar a média populacional com a média populacional da amostra 2. amostra2: Vetor contendo a amostra 2 para comparação da média populacional com a média populacional da amostra 1. Opções alternative: string indicando a hipótese alternativa desejada. Valores possíveis: “two-sided”, “less” ou “greater”. mu: valor indicando o verdadeiro valor da média populacional para o caso de uma amostra, ou a diferença entre as mêdias para o caso de duas amostras. paired: - TRUE - realiza o teste t pareado. - FALSE - realiza o teste t não pareado. var.equal: - TRUE - indica que a variância populacional é igual nas duas amostras. - FALSE - indica que a variância populacional de cada amostra é diferente. conf.level: coeficiente de confiança do intervalo. 7.1.1 Para uma média Vamos testar se a temperatura horaria do solsticio de verão no campo tem média igual ou maior que 21 ºC na cidade de Piracicaba-SP. H0: mu &gt;= 21 IC 95 para mu 1.0 Passo filtrar os dados pelo fator “periodo” com o nivel sol_verao (solsticio de verão). #Dividir os dados - subset() sol_verao_amb &lt;- subset(pira_tem, periodo == &quot;sol_verao&quot;) 2.0 Passo filtrar os dados pelo fator “local” com o nivel campo. sol_verao_camp &lt;- subset(sol_verao_amb, local == &quot;campo&quot;) 3.0 Verificar dados graficamente attach(pira_tem) boxplot(temp) 4.0 Usar o teste T t.test(sol_verao_camp$temp, #amostra a ser testada mu=21, #hipótese de nulidade alternative=&quot;greater&quot;, #teste unilateral pela direita conf.level = 0.95 ) #Intervalo de confiancia de 95% ## ## One Sample t-test ## ## data: sol_verao_camp$temp ## t = 21.648, df = 95, p-value &lt; 2.2e-16 ## alternative hypothesis: true mean is greater than 21 ## 95 percent confidence interval: ## 24.96332 Inf ## sample estimates: ## mean of x ## 25.29271 Agora basta fazer a interpretação correta da saída do R. Para saber qual hipótese foi aceita, basta verificar o valor do p-value e estipular um nível de significância. Se neste exemplo o nível de significância fosse de 5% a hipótese alternativa seria aceita uma vez que o p-value foi menor ou igual a 0,05. Caso o p-value tivesse sido maior que 5% então aceitaríamos a hipótese de nulidade. Como a hipótese alternativa foi a aceita isso implica que a temperatura do ar no solsticio de verão possui média estatisticamente diferente do valor 21ºC a um nível de significância de 5%. Exercicio 1 Vamos testar se X tem média estatiscamente igual a 35 ou maior H0: mu =&gt;35 x &lt;-c (30.5,35.3,33.2,40.8,42.3,41.5,36.3,43.2,34.6,38.5) boxplot(x) Teste t. t.test(x, mu=35, alternative = &quot;greater&quot;) ## ## One Sample t-test ## ## data: x ## t = 1.9323, df = 9, p-value = 0.04268 ## alternative hypothesis: true mean is greater than 35 ## 95 percent confidence interval: ## 35.13453 Inf ## sample estimates: ## mean of x ## 37.62 Com foi significativo admitimos que a amostra x é oriunda de um população com média maior que o valor de 35, com nivel de 5% de significância. Exercicio 2 Um pesquisador afirmou que a temperatura média de solsticio de verão medido na casa de vegetação em Piracicaba-SP tem média 22,2 ºC. Desconfiando desse resultado um outro pesquisador com dados provinientes da mesma estação climatológicas em períodos diferentes encontrou os seguintes resultados: H0: mu = 22,2 sol_verao_amb &lt;- subset(pira_tem, periodo == &quot;sol_verao&quot;) sol_verao_est &lt;- subset(sol_verao_amb, local == &quot;estufa&quot;) boxplot(sol_verao_est$temp) Essa afirmação é verdadeira? t.test(sol_verao_est$temp, #amostra a ser testada mu=22.2, #hipótese de nulidade alternative=&quot;two.sided&quot;, #teste bilateral não considera se é maior ou menor conf.level = 0.99) #significância de 1% ## ## One Sample t-test ## ## data: sol_verao_est$temp ## t = 10.98, df = 95, p-value &lt; 2.2e-16 ## alternative hypothesis: true mean is not equal to 22.2 ## 99 percent confidence interval: ## 25.06976 26.87629 ## sample estimates: ## mean of x ## 25.97302 7.1.2 Para duas médias independentes Para a realização do teste t pressupoe-se que as amostras possuem variâncias iguais alem de seguirem distribuição normal. Vamos a um exemplo: Suponha dois conjuntos de dados de temperatura de media do ar de dois ambientes(casa de vegetação e campo). Verifique se as temperaturas dos dois ambientes são estatisticamente diferentes usando 5% de significância. H0: mu da temp da casa de vegetação = mu da temp do campo boxplot(sol_verao_camp$temp, sol_verao_est$temp) t.test(sol_verao_camp$temp, sol_verao_est$temp, #amostras a serem testadas alternative = &quot;greater&quot;, #unilateral a direita var.equal = T ) #variância homogênea ## ## Two Sample t-test ## ## data: sol_verao_camp$temp and sol_verao_est$temp ## t = -1.7147, df = 190, p-value = 0.956 ## alternative hypothesis: true difference in means is greater than 0 ## 95 percent confidence interval: ## -1.336097 Inf ## sample estimates: ## mean of x mean of y ## 25.29271 25.97302 Uma vez que o p-value foi maior que 0,05, podemos concluir que as médias de temperatura dos dois ambientes não são diferentes, estatisticamente, a 5% de significância. Veja que o resultado desta analise mostra o valor de t (estatística do teste), os graus de liberdade (df) e o valor de p (significância). Alem disso, o resultado do teste ainda mostra as médias para cada grupo. 7.1.3 Para duas médias dependentes Neste caso vamos usar o mesmo nível de significância do exemplo das amostras independentes. As hipóteses se mantêm. Agora basta adicionar o argumento paired=T, informando que as amostras são dependentes. t.test(sol_verao_camp$temp, sol_verao_est$temp, #amostras a serem testadas conf.level=0.99, #nível de confiança paired=T, #indica dependência entre as amostras var.equal = T ) #variância homogênea ## ## Paired t-test ## ## data: sol_verao_camp$temp and sol_verao_est$temp ## t = -3.8433, df = 95, p-value = 0.0002193 ## alternative hypothesis: true difference in means is not equal to 0 ## 99 percent confidence interval: ## -1.1455999 -0.2150251 ## sample estimates: ## mean of the differences ## -0.6803125 Note que a estatística do teste-t pareado não é baseada na média dos tratamentos, e sim na diferença entre os pares de tratamentos. 7.2 Teste de variância 7.2.1 Usando o teste de F H0: a variancias das amostras são homogeneas var.test (sol_verao_camp$temp, sol_verao_est$temp) ## ## F test to compare two variances ## ## data: sol_verao_camp$temp and sol_verao_est$temp ## F = 0.33301, num df = 95, denom df = 95, p-value = 1.801e-07 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 95 percent confidence interval: ## 0.2221988 0.4990825 ## sample estimates: ## ratio of variances ## 0.3330098 As variâncias não são homogeneas. Vamos resolver novamente o exercicio anterior, modificando o argumento var.equal t.test(sol_verao_camp$temp, sol_verao_est$temp, #amostras a serem testadas conf.level=0.99, #nível de confiança paired=T, #indica dependência entre as amostras var.equal = F ) #variância homogênea ## ## Paired t-test ## ## data: sol_verao_camp$temp and sol_verao_est$temp ## t = -3.8433, df = 95, p-value = 0.0002193 ## alternative hypothesis: true difference in means is not equal to 0 ## 99 percent confidence interval: ## -1.1455999 -0.2150251 ## sample estimates: ## mean of the differences ## -0.6803125 7.3 Teste para a normalidade - shapiro.test() Por vezes temos necessidade de identificar com certa confiança se uma amostra ou conjunto de dados segue a distribuição normal. Isso e possível, no R, com o uso do comando shapiro.test() Verifique normalidade dos dados shapiro.test(sol_verao_camp$temp) ## ## Shapiro-Wilk normality test ## ## data: sol_verao_camp$temp ## W = 0.90789, p-value = 5.043e-06 shapiro.test(sol_verao_est$temp) ## ## Shapiro-Wilk normality test ## ## data: sol_verao_est$temp ## W = 0.85041, p-value = 2.027e-08 O comando qqnorm()nos fornece diretamente um gráfico da distribuição de percentagens acumuladas chamado de gráfico de probabilidade normal. Se os pontos deste gráfico seguem um padrão aproximado de uma reta, este fato evidencia que a variável aleatória em questão tem a distribuição aproximadamente normal. qqnorm(sol_verao_camp$temp) #obtendo o normal probability plot só para comparação qqnorm(sol_verao_est$temp) 7.4 Teste U de Mann-Whitney H0: mu da temp da casa de vegetação = mu da temp do campo wilcox.test(sol_verao_camp$temp,sol_verao_est$temp, alternative = &quot;two.side&quot;) ## ## Wilcoxon rank sum test with continuity correction ## ## data: sol_verao_camp$temp and sol_verao_est$temp ## W = 4579, p-value = 0.941 ## alternative hypothesis: true location shift is not equal to 0 7.5 Covariância e Correlação A covariância e a correlação entre dois conjuntos de dados quaisquer podem ser obtidos pelos comandos cov(x,y) e cor(x,y), respectivamente. São medidads utilizadas no estudo do comportamento conjunto de duas variáveis quantitativas distintas. Elas informam a variação conjunta (covarincia) ou grau de associaçãp (correlação) entre duas variaveis aleatorias X e Y. A correlação de Pearson é uma medida paramétrica de associação linear entre duas variaveis. A correlação de ordem de Sperman é uma medidad não paramétrica de associação entre duas variáveis A correlação de ordem de Kendall é outra medida não paramétrica da associação, baseada na concordância ou discordância dos pares x-y help (&quot;cor.test&quot;) Plote os valores plot(sol_verao_camp$temp,sol_verao_est$temp, las=2) Teste de correlação de Pearson cor(sol_verao_camp$temp,sol_verao_est$temp, method = &quot;pearson&quot; ) ## [1] 0.9250728 Teste de correlação de Pearson (the default) cor(sol_verao_camp$temp,sol_verao_est$temp) ## [1] 0.9250728 Teste de correlação de Pearson trocando o X e Y cor(sol_verao_est$temp, sol_verao_camp$temp) ## [1] 0.9250728 Teste de correlação de Spearman cor(sol_verao_camp$temp,sol_verao_est$temp, method = &quot;spearman&quot;) ## [1] 0.9412321 Teste de correlação de Kendall cor(sol_verao_camp$temp,sol_verao_est$temp, method = &quot;kendall&quot;) ## [1] 0.8113615 Teste de correlação de Pearson cor.test (sol_verao_camp$temp,sol_verao_est$temp, method = &quot;pearson&quot; ) ## ## Pearson&#39;s product-moment correlation ## ## data: sol_verao_camp$temp and sol_verao_est$temp ## t = 23.615, df = 94, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.8895702 0.9494668 ## sample estimates: ## cor ## 0.9250728 cor.test (sol_verao_camp$temp,sol_verao_est$temp, method = &quot;spearman&quot; ) ## Warning in cor.test.default(sol_verao_camp$temp, sol_verao_est$temp, method = ## &quot;spearman&quot;): Cannot compute exact p-value with ties ## ## Spearman&#39;s rank correlation rho ## ## data: sol_verao_camp$temp and sol_verao_est$temp ## S = 8664.7, p-value &lt; 2.2e-16 ## alternative hypothesis: true rho is not equal to 0 ## sample estimates: ## rho ## 0.9412321 cor.test (sol_verao_camp$temp,sol_verao_est$temp, method = &quot;spearman&quot;, exact = F ) ## ## Spearman&#39;s rank correlation rho ## ## data: sol_verao_camp$temp and sol_verao_est$temp ## S = 8664.7, p-value &lt; 2.2e-16 ## alternative hypothesis: true rho is not equal to 0 ## sample estimates: ## rho ## 0.9412321 cov (sol_verao_camp$temp,sol_verao_est$temp) ## [1] 6.051517 7.6 Outros testes Utilizaremos o banco de dados dadosfisio fisio &lt;- read.csv2(&quot;https://www.dropbox.com/s/zg7fyg1iewtji49/dadosfisio.csv?dl=1&quot;) attach(fisio) ## The following objects are masked _by_ .GlobalEnv: ## ## a, b, x, y, z pairs(fisio[,4:10]) Teste de Spearman cor(fisio[,3:8],method = &quot;spearman&quot;) ## y cota ds cc ma ## y 1.000000000 0.03913488 -0.007304133 -0.005043318 -0.02834692 ## cota 0.039134875 1.00000000 -0.625860523 0.506913897 0.51222110 ## ds -0.007304133 -0.62586052 1.000000000 -0.719094380 -0.80918958 ## cc -0.005043318 0.50691390 -0.719094380 1.000000000 0.40193585 ## ma -0.028346924 0.51222110 -0.809189577 0.401935847 1.00000000 ## ptotal -0.001391263 0.54405131 -0.962597591 0.812104786 0.75424837 ## ptotal ## y -0.001391263 ## cota 0.544051305 ## ds -0.962597591 ## cc 0.812104786 ## ma 0.754248369 ## ptotal 1.000000000 7.6.1 hydroGOF Carregando a biblioteca hydroGOF, que contém dados e funções usadas nesta análise. library(hydroGOF) ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric Cálculo das medidas numéricas de qualidade do ajuste para o “melhor” caso (inatingível) gof(sim = fisio$ds, obs= fisio$cc) ## [,1] ## ME 1.36 ## MAE 1.36 ## MSE 1.90 ## RMSE 1.38 ## NRMSE % 1866.00 ## PBIAS % 453.80 ## RSR 18.66 ## rSD 2.24 ## NSE -350.47 ## mNSE -20.82 ## rNSE -460.60 ## d 0.07 ## md 0.04 ## rd -0.22 ## cp -911.57 ## r -0.87 ## R2 0.75 ## bR2 0.15 ## KGE -4.06 ## VE -3.54 "],
["analise-de-variância-anova.html", " 8 Analise de variância (ANOVA) 8.1 Delineamento inteiramente casualizado 8.2 Delineamento em bloco casualizado 8.3 Quadrado Latino 8.4 Regressão Linear simples 8.5 Regressão não linear 8.6 Resolução do Livro Banzatto Kronka", " 8 Analise de variância (ANOVA) Estudos estatísticos contemporâneos contemplam a análise de variância tendo em vista que este procedimento permite identificar e quantificar as variações ocorridas em um experimento, discriminando a parte da variação associada ao modelo pelo qual o experimento foi procedido da variação que se dá devido ao acaso. No R encontram-se diversos procedimentos para se executar a ANOVA. A tabela abaixo mostra alguns modelos e suas usuais formulações: Modelo Fórmula Comentário DIC y~t t é um fator DBC y~t+b t e b são fatores DQL y~t+l+c t, l e c são fatores Fatorial/ DIC y~N*P igual a N + P + N:P Fatorial/ DBC y~b+N*P igual a b+N+P+N:P Regressão linear simples y~x x é uma variável exploratória Regressão quadrática y~x+x2 x2 é um objeto x2&lt;-x^2 Os modelos de análise de variância simples podem ser trabalhados também a partir da função lm() simplesmente indicando um fator como variável independente. No entanto, existem outras funções que também realizam análises de variância para casos específicos (como a aov() para amostras balanceadas) ou modelos lineares mais complexos como análise de modelos mistos ou hierarquicas função lme() do pacote nlme e modelos não lineares nls() e glm() para ANOVA, com estrutura de erros especificada. 8.1 Delineamento inteiramente casualizado O delineamento inteiramente casualizado é o mais simples de todos os delineamentos experimentais. Este delineamento apresenta as seguintes caracterítiscas: Utiliza apenas os princópios da repetição e da casualização, deixando de lado o principio do controle local, e, portanto, as repetições não são organizadas em blocos; Os tratamentos são designados às parcelas de forma inteiramente casual, com números iguais ou diferentes repetições por tratamento. Vantagens em relações a outros delineamentos é um delineamento bastante flexível, visto que o número de tratamentos e de repetições depende apenas do número de parcelas disponíveis; o número de repetições pode ser diferente de um tratamento para outro; a análise estatística é simples, mesmo quando o número de repetições por tratamento é variável; o número de grau de liberdade para o resíduo é o maior possível; Desvantagens em relações a outros delineamentos exige homogeneidade total das condições experimentais; pode conduzir a uma estimativa de variância residual bastante alta, uma vez que, não se aplica o controle local; Este delineamento é mais utilizado em experimentos de laboratório e nos ensaios com vasos, realizados dentro de casas de vegetação, nos quais as condições experimentais podem ser controladas. Nos experimentos realizados com vasos, estes devem ser cte mudados de posição, de forma interamente casual. 8.1.1 Análise de experimento em DIC Dados de um experimento visando controle de pulgão (Aphis gossypii Glover) em cultura de pepino, instalado em delineamento inteiramente casualizado com 6 repetições. A resposta observada foi o número de pulgões após a aplicação de produtos indicados para seu controle. O primeiro passo é ler os dados. Importando dados dados &lt;- read.table(&quot;https://www.dropbox.com/s/jjyo8dhyy0qt3ft/BanzattoQd3.2.1.txt?dl=1&quot;) Conferir se temos fatores para fazer a análise de variância str(dados) ## &#39;data.frame&#39;: 30 obs. of 3 variables: ## $ trat : Factor w/ 5 levels &quot;Azinfos etilico&quot;,..: 5 1 3 4 2 5 1 3 4 2 ... ## $ rept : int 1 1 1 1 1 2 2 2 2 2 ... ## $ pulgoes: int 2370 1282 562 173 193 1687 1527 321 127 71 ... Lembramos que pulgoes deve ter conteudo numerico e trat deve ser fator dados$trat&lt;-as.factor(dados$trat) dados$pulgoes&lt;-as.numeric(dados$pulgoes) Verificação gráfica** É importante notar que as barras simplesmente refletem a variância dos dados dentro da cada tratamento e não são adequadas para detectar diferenças entre tratamentos. plot(dados$trat, dados$pulgoes) 8.1.2 Análise de variância Fazendo a análise de variância m0 &lt;- lm (dados$pulgoes ~ dados$trat) anova(m0) ## Analysis of Variance Table ## ## Response: dados$pulgoes ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## dados$trat 4 23145259 5786315 81.79 5.505e-14 *** ## Residuals 25 1768644 70746 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Extraindo o coeficiente de variação require(agricolae) ## Loading required package: agricolae cv.model(m0) ## [1] 30.73619 Análise gráfica dos resíduos par(mfrow = c(2,2)) plot(m0) Analisando a Figura acima sugere que o principal problema deste conjunto de dados pode ser a heterosdasticidade. A variabilidade dos erros apresentam um forma de cone. Teste das pressuposições da análise de variância** # Teste de Bartllet para homocedasticidade bartlett.test(m0$res, dados$trat) ## ## Bartlett test of homogeneity of variances ## ## data: m0$res and dados$trat ## Bartlett&#39;s K-squared = 29.586, df = 4, p-value = 5.942e-06 Como observamos uma significancia estatística neste resultado, devemos rejeitar a hipótese nula de que as variâncias sejam as mesma em todos os níveis do fator. Teste de Shapiro-Wilk para Normalidade shapiro.test(m0$res) ## ## Shapiro-Wilk normality test ## ## data: m0$res ## W = 0.89608, p-value = 0.006742 8.1.3 Transformação de dados Tranformação de dados é uma das possíveis formas de contarnar o problema de dados que não obedecem os pressupostos da análise de variância. Vamos ver como isto poder ser feito com o programa R. Nos resultados acima vemos que a homogeneidade de variâncias foi rejeitada. Para tentar contornar o problema podemos utilizar catalogos de transformação: Transformação de raiz quadrada: frequentemente utilizada para dados de contagens, que geralmente seguem a distribuição de Poison, na qual a média é igual a variância. Quando ocorrem zeros ou valores baixos (menores que 10 ou 15), as transformação recomendadas são raiz quadrada + 0,5 ou 1,0. Transformação angular: recomendavel para dados expressos em porcentagens, que geralmente segue distribuição binomial. Transformação logarítima: utilizada quando é constatada certa proporcionalidade entre as médias e os desvios padrões dos diversos tratamentos. m1 &lt;- lm (log(dados$pulgoes) ~ dados$trat) 8.1.3.1 Transformação de dados BOX-COX Para tentar contornar o problema vamos usar a transformação Box-Cox, que consiste em transformar os dados de acordo com uma expressão. A função boxcox() do pacote MASS calcula a verossimilhança perfilhada do parâmetro. Devemos escolher o valor que maximiza esta função. Nos comandos a seguir começamos carregando o pacote MASS e depois obtemos o gráfico da verossimilhança perfilhada. Como estamos interessados no máximo fazermos um novo gráfico com um zoom na região de interesse require(MASS) ## Loading required package: MASS boxcox(m0) #Com zoom boxcox(m0, lam = seq(-1, 1, 1/10)) boxcox(m0) abline(v=0.2) locator() 8.1.3.2 Análise de variância - Ajuste com a variável transformada. m1 &lt;- lm (dados$pulgoes^0.2 ~ dados$trat, data = dados) análise gráfica dos resíduos par(mfrow = c(2,2)) plot(m1) Os pressupostos foram atendindos Teste de Shapiro-Wilk para Normalidade shapiro.test(m1$res) ## ## Shapiro-Wilk normality test ## ## data: m1$res ## W = 0.97288, p-value = 0.6207 Teste de Bartllet para homocedasticidade bartlett.test(m1$res, dados$trat) ## ## Bartlett test of homogeneity of variances ## ## data: m1$res and dados$trat ## Bartlett&#39;s K-squared = 2.7641, df = 4, p-value = 0.598 Resumo do modelo ajustado - Contraste summary(m1) ## ## Call: ## lm(formula = dados$pulgoes^0.2 ~ dados$trat, data = dados) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.33971 -0.10602 -0.02286 0.14069 0.44317 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.02268 0.08709 46.191 &lt; 2e-16 *** ## dados$tratDiazinon 60CE -1.60093 0.12316 -12.999 1.27e-12 *** ## dados$tratSupracid 40CE dose 1 -0.55418 0.12316 -4.500 0.000136 *** ## dados$tratSupracid 40CE dose 2 -1.28606 0.12316 -10.442 1.33e-10 *** ## dados$tratTestemunha 0.73703 0.12316 5.984 3.00e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2133 on 25 degrees of freedom ## Multiple R-squared: 0.95, Adjusted R-squared: 0.942 ## F-statistic: 118.8 on 4 and 25 DF, p-value: 6.978e-16 Resumo do modelo ajustado - Contraste em relação a testemunha dados$trat &lt;- relevel(dados$trat, &quot;Testemunha&quot;) m1 &lt;- lm (dados$pulgoes^0.2 ~ dados$trat, data = dados) summary(m1) ## ## Call: ## lm(formula = dados$pulgoes^0.2 ~ dados$trat, data = dados) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.33971 -0.10602 -0.02286 0.14069 0.44317 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.75972 0.08709 54.654 &lt; 2e-16 *** ## dados$tratAzinfos etilico -0.73703 0.12316 -5.984 3.00e-06 *** ## dados$tratDiazinon 60CE -2.33797 0.12316 -18.983 2.31e-16 *** ## dados$tratSupracid 40CE dose 1 -1.29122 0.12316 -10.484 1.23e-10 *** ## dados$tratSupracid 40CE dose 2 -2.02310 0.12316 -16.426 6.62e-15 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2133 on 25 degrees of freedom ## Multiple R-squared: 0.95, Adjusted R-squared: 0.942 ## F-statistic: 118.8 on 4 and 25 DF, p-value: 6.978e-16 8.1.4 Aplicando teste de Tukey para comparar médias No R, o teste de Tukey é apresentado através de intervalos de confiança. A interpretação é: se o intervalo de confiança para a diferença entre duas médias não incluir o valor zero, significa que se rejeita a hipótese nula, caso contrário, não se rejeita. O resultado pode ser visto através de uma tabela e/ou graficamente: m1 &lt;- aov (dados$pulgoes^0.2 ~ dados$trat, data = dados) dados.tu &lt;- TukeyHSD (m1) print(dados.tu) ## Tukey multiple comparisons of means ## 95% family-wise confidence level ## ## Fit: aov(formula = dados$pulgoes^0.2 ~ dados$trat, data = dados) ## ## $`dados$trat` ## diff lwr upr ## Azinfos etilico-Testemunha -0.7370340 -1.09874544 -0.3753225 ## Diazinon 60CE-Testemunha -2.3379681 -2.69967961 -1.9762567 ## Supracid 40CE dose 1-Testemunha -1.2912155 -1.65292701 -0.9295041 ## Supracid 40CE dose 2-Testemunha -2.0230984 -2.38480982 -1.6613869 ## Diazinon 60CE-Azinfos etilico -1.6009342 -1.96264562 -1.2392227 ## Supracid 40CE dose 1-Azinfos etilico -0.5541816 -0.91589302 -0.1924701 ## Supracid 40CE dose 2-Azinfos etilico -1.2860644 -1.64777584 -0.9243529 ## Supracid 40CE dose 1-Diazinon 60CE 1.0467526 0.68504114 1.4084641 ## Supracid 40CE dose 2-Diazinon 60CE 0.3148698 -0.04684168 0.6765812 ## Supracid 40CE dose 2-Supracid 40CE dose 1 -0.7318828 -1.09359428 -0.3701714 ## p adj ## Azinfos etilico-Testemunha 0.0000277 ## Diazinon 60CE-Testemunha 0.0000000 ## Supracid 40CE dose 1-Testemunha 0.0000000 ## Supracid 40CE dose 2-Testemunha 0.0000000 ## Diazinon 60CE-Azinfos etilico 0.0000000 ## Supracid 40CE dose 1-Azinfos etilico 0.0011809 ## Supracid 40CE dose 2-Azinfos etilico 0.0000000 ## Supracid 40CE dose 1-Diazinon 60CE 0.0000001 ## Supracid 40CE dose 2-Diazinon 60CE 0.1099096 ## Supracid 40CE dose 2-Supracid 40CE dose 1 0.0000307 plot(dados.tu) Teste Tukey com pacote Agricolae library(agricolae) summary(m1) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## dados$trat 4 21.629 5.407 118.8 6.98e-16 *** ## Residuals 25 1.138 0.046 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 tu &lt;- HSD.test(y = dados$pulgoes^0.2, trt = dados$trat, MSerror = deviance(m1)/df.residual(m1), #quadrado médio do residuo DFerror = df.residual(m1), console = T) ## ## Study: dados$pulgoes^0.2 ~ dados$trat ## ## HSD Test for dados$pulgoes^0.2 ## ## Mean Square Error: 0.04550677 ## ## dados$trat, means ## ## dados.pulgoes.0.2 std r Min Max ## Azinfos etilico 4.022682 0.1967278 6 3.830812 4.332792 ## Diazinon 60CE 2.421748 0.2492525 6 2.131526 2.864913 ## Supracid 40CE dose 1 3.468500 0.2678917 6 3.163821 3.846471 ## Supracid 40CE dose 2 2.736617 0.1264052 6 2.634879 2.959410 ## Testemunha 4.759716 0.1973855 6 4.420008 4.965939 ## ## Alpha: 0.05 ; DF Error: 25 ## Critical Value of Studentized Range: 4.153363 ## ## Minimun Significant Difference: 0.3617115 ## ## Treatments with the same letter are not significantly different. ## ## dados$pulgoes^0.2 groups ## Testemunha 4.759716 a ## Azinfos etilico 4.022682 b ## Supracid 40CE dose 1 3.468500 c ## Supracid 40CE dose 2 2.736617 d ## Diazinon 60CE 2.421748 d str(tu) ## List of 5 ## $ statistics:&#39;data.frame&#39;: 1 obs. of 5 variables: ## ..$ MSerror: num 0.0455 ## ..$ Df : int 25 ## ..$ Mean : num 3.48 ## ..$ CV : num 6.13 ## ..$ MSD : num 0.362 ## $ parameters:&#39;data.frame&#39;: 1 obs. of 5 variables: ## ..$ test : Factor w/ 1 level &quot;Tukey&quot;: 1 ## ..$ name.t : Factor w/ 1 level &quot;dados$trat&quot;: 1 ## ..$ ntr : int 5 ## ..$ StudentizedRange: num 4.15 ## ..$ alpha : num 0.05 ## $ means :&#39;data.frame&#39;: 5 obs. of 8 variables: ## ..$ dados$pulgoes^0.2: num [1:5] 4.02 2.42 3.47 2.74 4.76 ## ..$ std : num [1:5] 0.197 0.249 0.268 0.126 0.197 ## ..$ r : int [1:5] 6 6 6 6 6 ## ..$ Min : num [1:5] 3.83 2.13 3.16 2.63 4.42 ## ..$ Max : num [1:5] 4.33 2.86 3.85 2.96 4.97 ## ..$ Q25 : num [1:5] 3.88 2.3 3.24 2.65 4.7 ## ..$ Q50 : num [1:5] 3.96 2.38 3.5 2.69 4.77 ## ..$ Q75 : num [1:5] 4.14 2.47 3.61 2.78 4.9 ## $ comparison: NULL ## $ groups :&#39;data.frame&#39;: 5 obs. of 2 variables: ## ..$ dados$pulgoes^0.2: num [1:5] 4.76 4.02 3.47 2.74 2.42 ## ..$ groups : Factor w/ 4 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;: 1 2 3 4 4 ## - attr(*, &quot;class&quot;)= chr &quot;group&quot; tu$groups ## dados$pulgoes^0.2 groups ## Testemunha 4.759716 a ## Azinfos etilico 4.022682 b ## Supracid 40CE dose 1 3.468500 c ## Supracid 40CE dose 2 2.736617 d ## Diazinon 60CE 2.421748 d write.table(tu$groups, &quot;tab.xls&quot;, sep = &quot;\\t&quot;, quote = F, row.names = F) 8.1.5 Aplicando teste para agrupar médias carregando a biblioteca necessária #install.packages(&quot;laercio&quot;) require(laercio) ## Loading required package: laercio Teste de Duncan LDuncan (m1, &quot;dados$trat&quot;) ## ## DUNCAN TEST TO COMPARE MEANS ## ## Confidence Level: 0.95 ## Dependent Variable: dados$pulgoes^0.2 ## Variation Coefficient: 6.126714 % ## ## ## Independent Variable: dados$trat ## Factors Means ## Testemunha 4.75971565312899 a ## Azinfos etilico 4.02268167030532 b ## Supracid 40CE dose 1 3.46850010815533 c ## Supracid 40CE dose 2 2.73661729164913 d ## Diazinon 60CE 2.42174750727391 e LTukey (m1, &quot;dados$trat&quot;) ## ## TUKEY TEST TO COMPARE MEANS ## ## Confidence level: 0.95 ## Dependent variable: dados$pulgoes^0.2 ## Variation Coefficient: 6.126714 % ## ## Independent variable: dados$trat ## Factors Means ## Testemunha 4.75971565312899 a ## Azinfos etilico 4.02268167030532 b ## Supracid 40CE dose 1 3.46850010815533 c ## Supracid 40CE dose 2 2.73661729164913 d ## Diazinon 60CE 2.42174750727391 d ## ## Pacote para analise de experimentos library(ExpDes.pt) ## ## Attaching package: &#39;ExpDes.pt&#39; ## The following object is masked from &#39;package:MASS&#39;: ## ## ginv ## The following objects are masked from &#39;package:agricolae&#39;: ## ## lastC, order.group, tapply.stat ## The following object is masked from &#39;package:stats&#39;: ## ## ccf Recursos adicionais para comparações múltiplas Outros procedimentos serão implementados em pacotes contribuídos do R. Entre estes encontra-se os pacotes multcomp e multcompView que implementam diversos outros procedimentos e gráficos para visualizações dos resultados. Vale notar que estes pacotes devem ser instalados com a opção dependencies=TRUE para garantir plena funcionalidade pois suas funções dependem de diversos outros pacotes. #install.packages(&quot;multcompView&quot;, dep = TRUE) require(multcomp) ## Loading required package: multcomp ## Loading required package: mvtnorm ## Loading required package: survival ## Loading required package: TH.data ## ## Attaching package: &#39;TH.data&#39; ## The following object is masked from &#39;package:MASS&#39;: ## ## geyser require(multcompView) ## Loading required package: multcompView multcompBoxplot(pulgoes ~ trat, data = dados, compFn = &quot;TukeyHSD&quot;, decreasing = FALSE) 8.1.6 Referência MELO, M. P.; PETERNELI, L. A. Conhecendo o R: Um visão mais que estatística. Viçosa, MG: UFV, 2013. 222p. Cap. 1. BANZATTO, D. A; KRONKA, S. N. Experimentação agrícola. Jaboticabal, SP: FUNEP, 2006, 237p. ZEVIANI, W. M. estatística Básica e Experimentação no R. 45p. http://www.leg.ufpr.br/~paulojus/ 8.2 Delineamento em bloco casualizado O delineamento em blocos casualizados (DBC) tem três princípios basicos de experimentação: repetição casualização controle local É o deliamento mais utilizado de todos delineamento. Ele é utilizado quando há heterogeneidade nas condições experimentais. Nesse caso divide-se o material experimental, ou amostra, em bloco homogêneos de forma a contemplar as diferenças entre grupos. A ANOVA associada a este modelo de experimento é também conhecida como Two Way ANOVA. 8.2.1 Análise de experimento DBC Resultados de um experimento instalado na Fazenda Chapadão, no município de Angatuba - SP. O delineamento experimental foi o de blocos casualizados, sendo as parcelas constituídas de 4 plantas espa?adas de 6 x 7 metros, com 12 anos de idade na época da instalação do experimento. Importando dados dados &lt;- read.table(&quot;https://www.dropbox.com/s/9woiye3ce9twp78/BanzattoQd4.5.2.txt?dl=1&quot;) conferir se temos fatores para fazer a análise de variância str(dados) ## &#39;data.frame&#39;: 20 obs. of 3 variables: ## $ promalin: Factor w/ 5 levels &quot;12.5&quot;,&quot;12.5+12.5&quot;,..: 1 3 4 2 5 1 3 4 2 5 ... ## $ bloco : Factor w/ 4 levels &quot;I&quot;,&quot;II&quot;,&quot;III&quot;,..: 1 1 1 1 1 2 2 2 2 2 ... ## $ peso : num 142 140 141 151 154 ... Lembramos que o peso deve ter conteudo numerico e o promalin e bloco deve ser fator. dados$promalin&lt;-as.factor(dados$promalin) dados$bloco&lt;-as.numeric(dados$bloco) Verificação gráfica** require(lattice) ## Loading required package: lattice xyplot(peso ~ promalin, groups = bloco, data= dados) O efeito do bloco é aditivo? Ligar as observações com o mesmo bloco com a função type =\"o\" xyplot(peso ~ reorder(promalin, peso), groups = bloco, data= dados, type = &quot;o&quot;) Reordenar os tratamentos require(plyr) ## Loading required package: plyr dados$promalin &lt;- with(dados, reorder(promalin, peso)) dados &lt;- arrange(dados, promalin, bloco) Graficos reordenados da menor média a maior média por tratamento xyplot(peso ~ reorder(promalin, peso), groups = bloco, data= dados, type = &quot;o&quot;) 8.2.1.1 Análise de variância Fazendo a análise de variância m0 &lt;- lm (dados$peso ~ dados$bloco + dados$promalin, data = dados) anova(m0) ## Analysis of Variance Table ## ## Response: dados$peso ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## dados$bloco 1 71.57 71.572 2.4574 0.139291 ## dados$promalin 4 788.95 197.238 6.7721 0.002994 ** ## Residuals 14 407.75 29.125 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Extraindo o coeficiente de variação require(agricolae) cv.model(m0) ## [1] 3.774477 Análise gráfica dos resíduos par(mfrow= c(2,2)) plot(m0) Analisando a Figura acima sugere que o principal problema deste conjunto de dados pode ser a não normalidade. 8.2.1.1.1 Teste das pressuposições da análise de variância 8.2.1.1.1.0.1 Teste de Bartllet para homocedasticidade bartlett.test(m0$res, dados$promalin) ## ## Bartlett test of homogeneity of variances ## ## data: m0$res and dados$promalin ## Bartlett&#39;s K-squared = 1.7485, df = 4, p-value = 0.7819 Como observamos uma não significancia estatística neste resultado (p-value = 0.7819), devemos aceitar a hipótese nula de que as variâncias sejam as mesma em todos os níveis do fator. 8.2.1.1.1.0.2 Teste de Shapiro-Wilk para Normalidade shapiro.test(m0$res) ## ## Shapiro-Wilk normality test ## ## data: m0$res ## W = 0.855, p-value = 0.006472 Como observamos uma significancia estatística neste resultado (p-value = 0.006472), devemos rejeitar a hipótese nula de que os residuoes tedem a distruibuição normal. 8.2.1.2 Transformação de dados Tranformação de dados é uma das possíveis formas de contarnar o problema de dados que não obedecem os pressupostos da análise de variância. Vamos ver como isto poder ser feito com o programa R. 8.2.1.2.1 Transformação de dados com o BOX-COX Para tentar contornar o problema vamos usar a transformação Box-Cox, que consiste em transformar os dados de acordo com uma expressão. A função boxcox() do pacote MASS calcula a verossimilhança perfilhada do parâmetro lambda. Devemos escolher o valor que maximiza esta função. Nos comandos a seguir começamos carregando o pacote MASS e depois obtemos o gráfico da verossimilhança perfilhada. Como estamos interessados no máximo fazermos um novo gráfico com um zoom na região de interesse. require(MASS) boxcox(m0) boxcox(m0, lam = seq(-8, 8, 1/10)) Localizando o ponto máximo. 8.2.1.2.2 Análise de variância - Ajuste com a variável transformada. m1 &lt;- aov (log(dados$peso) ~ dados$promalin, data = dados) Anáise gráfica dos resíduos par(mfrow = c(2,2)) plot(m1) Os pressupostos foram atendindos ? Teste de Shapiro-Wilk para Normalidade shapiro.test(m1$res) ## ## Shapiro-Wilk normality test ## ## data: m1$res ## W = 0.93909, p-value = 0.2305 Teste de Bartllet para homocedasticidade bartlett.test(m1$res, dados$promalin) ## ## Bartlett test of homogeneity of variances ## ## data: m1$res and dados$promalin ## Bartlett&#39;s K-squared = 2.1761, df = 4, p-value = 0.7034 anova(m1) ## Analysis of Variance Table ## ## Response: log(dados$peso) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## dados$promalin 4 0.036571 0.0091428 6.0129 0.004296 ** ## Residuals 15 0.022808 0.0015205 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 8.2.2 Pacote para analise de experimentos library(ExpDes.pt) Conhecer o pacote ExpDes.pt ls(&quot;package:ExpDes.pt&quot;) ## [1] &quot;anscombetukey&quot; &quot;bartlett&quot; &quot;ccboot&quot; &quot;ccf&quot; ## [5] &quot;dbc&quot; &quot;dic&quot; &quot;dql&quot; &quot;duncan&quot; ## [9] &quot;faixas&quot; &quot;fat2.ad.dbc&quot; &quot;fat2.ad.dic&quot; &quot;fat2.dbc&quot; ## [13] &quot;fat2.dic&quot; &quot;fat3.ad.dbc&quot; &quot;fat3.ad.dic&quot; &quot;fat3.dbc&quot; ## [17] &quot;fat3.dic&quot; &quot;ginv&quot; &quot;graficos&quot; &quot;han&quot; ## [21] &quot;lastC&quot; &quot;layard&quot; &quot;levene&quot; &quot;lsd&quot; ## [25] &quot;lsdb&quot; &quot;oneilldbc&quot; &quot;oneillmathews&quot; &quot;order.group&quot; ## [29] &quot;order.stat.SNK&quot; &quot;plotres&quot; &quot;psub2.dbc&quot; &quot;psub2.dic&quot; ## [33] &quot;reg.nl&quot; &quot;reg.poly&quot; &quot;samiuddin&quot; &quot;scottknott&quot; ## [37] &quot;snk&quot; &quot;tapply.stat&quot; &quot;tukey&quot; Utilizando o exemplo anterior. x &lt;- dbc(trat = dados$promalin, bloco = dados$bloco, resp = log(dados$peso), quali = T, mcomp = &quot;tukey&quot;) ## ------------------------------------------------------------------------ ## Quadro da analise de variancia ## ------------------------------------------------------------------------ ## GL SQ QM Fc Pr&gt;Fc ## Tratamento 4 0.036571 0.0091428 5.7552 0.00800 ## Bloco 3 0.003745 0.0012483 0.7858 0.52459 ## Residuo 12 0.019063 0.0015886 ## Total 19 0.059379 ## ------------------------------------------------------------------------ ## CV = 0.8 % ## ## ------------------------------------------------------------------------ ## Teste de normalidade dos residuos ## valor-p: 0.005994506 ## ATENCAO: a 5% de significancia, os residuos nao podem ser considerados normais! ## ------------------------------------------------------------------------ ## ## ------------------------------------------------------------------------ ## Teste de homogeneidade de variancia ## valor-p: 0.8927087 ## De acordo com o teste de oneillmathews a 5% de significancia, as variancias podem ser consideradas homogeneas. ## ------------------------------------------------------------------------ ## ## Teste de Tukey ## ------------------------------------------------------------------------ ## Grupos Tratamentos Medias ## a Testemunha 5.043544 ## ab 12.5 4.961465 ## b 12.5+12.5 4.940843 ## b 50.0 4.932278 ## b 25.0 4.927864 ## ------------------------------------------------------------------------ Carregar pacotes library(ggplot2) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:plyr&#39;: ## ## arrange, count, desc, failwith, id, mutate, rename, summarise, ## summarize ## The following object is masked from &#39;package:MASS&#39;: ## ## select ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union Calculo do erro erro = summarise(group_by(dados, promalin), avg = mean(peso), sd = sd(peso)) Gerando gráfico ggplot(erro, aes(promalin, avg, fill=promalin))+ geom_bar(stat=&quot;identity&quot;)+ geom_errorbar(aes(ymin=avg-sd, ymax =avg+sd), with=0.1, col=&quot;black&quot;) + xlab(&quot;Tratamentos&quot;) + ylab(&quot;Peso médio dos frutos (g)&quot;) + theme_bw() + theme(legend.position=&quot;top&quot;) + annotate(&quot;text&quot;, label=&quot;ab&quot;, x=1, y=100, size = 5) + annotate(&quot;text&quot;, label=&quot;b&quot;, x=2, y=100, size = 5) + annotate(&quot;text&quot;, label=&quot;b&quot;, x=3, y=100, size = 5) + annotate(&quot;text&quot;, label=&quot;b&quot;, x=4, y=100, size = 5) + annotate(&quot;text&quot;, label=&quot;a&quot;, x=5, y=100, size = 5) + theme(legend.position=&quot;none&quot;) + labs(caption = &quot;Médias seguidas de mesma letra indicam diferença nula à 5%&quot;) ## Warning: Ignoring unknown parameters: with 8.2.3 Teste não parametrico As funções para comparações multiplas não-paramétricas incluídas no pacote agricolae são: kruskal, waerden.test, friedman, durbin.test e Conover (1999). Os testes não-paramétricos post hoc (kruskal, friedman, durbin e waerden) estão usando o critério a diferença menos significativa de Fisher (LSD). Carregar pacote library(agricolae) A função kruskal é usada para N amostras (N&gt; 2), populações ou dados provenientes de um experimento aleatório (populações = tratamentos). woutKruskal&lt;-with(dados,kruskal(promalin, y = peso ,p.adj=&quot;bon&quot;,group=T, console=T)) ## ## Study: peso ~ promalin ## Kruskal-Wallis test&#39;s ## Ties or no Ties ## ## Critical Value: 10.41429 ## Degrees of freedom: 4 ## Pvalue Chisq : 0.03399839 ## ## promalin, means of the ranks ## ## peso r ## 12.5 12.00 4 ## 12.5+12.5 7.75 4 ## 25.0 7.50 4 ## 50.0 7.00 4 ## Testemunha 18.25 4 ## ## Post Hoc Analysis ## ## P value adjustment method: bonferroni ## t-Student: 3.286039 ## Alpha : 0.05 ## Minimum Significant Difference: 10.40002 ## ## Treatments with the same letter are not significantly different. ## ## peso groups ## Testemunha 18.25 a ## 12.5 12.00 ab ## 12.5+12.5 7.75 b ## 25.0 7.50 b ## 50.0 7.00 b print(woutKruskal$group) ## peso groups ## Testemunha 18.25 a ## 12.5 12.00 ab ## 12.5+12.5 7.75 b ## 25.0 7.50 b ## 50.0 7.00 b Gráficos par(mfrow=c(2,2),mar=c(3,3,1,1),cex=0.8) bar.group(woutKruskal$group,ylim=c(0,100), xlab =&quot;promalin&quot;) bar.group(woutKruskal$group,xlim=c(0,100),horiz = TRUE) plot(woutKruskal) plot(woutKruskal,variation=&quot;IQR&quot;,horiz = TRUE) A função friedman é usada para análise de tratamentos do estudo randomizado de bloco completo, onde a resposta não pode ser tratada através da análise de variância. woutfriedman &lt;- out&lt;-with(dados,friedman(bloco,promalin, peso,alpha=0.05, group=T, console=TRUE)) ## ## Study: peso ~ bloco + promalin ## ## promalin, Sum of the ranks ## ## peso r ## 12.5 8 4 ## 12.5+12.5 8 4 ## 25.0 10 4 ## 50.0 14 4 ## Testemunha 20 4 ## ## Friedman&#39;s Test ## =============== ## Adjusted for ties ## Critical Value: 10.4 ## P.Value Chisq: 0.0342027 ## F Value: 5.571429 ## P.Value F: 0.009007502 ## ## Post Hoc Analysis ## ## Alpha: 0.05 ; DF Error: 12 ## t-Student: 2.178813 ## LSD: 6.656383 ## ## Treatments with the same letter are not significantly different. ## ## Sum of ranks groups ## Testemunha 20 a ## 50.0 14 ab ## 25.0 10 b ## 12.5 8 b ## 12.5+12.5 8 b Grafico par(mfrow=c(2,2),mar=c(3,3,1,1),cex=0.8) bar.group(woutfriedman$group,ylim=c(0,100), xlab =&quot;promalin&quot;) bar.group(woutfriedman$group,xlim=c(0,100),horiz = TRUE) plot(woutfriedman) plot(woutfriedman,variation=&quot;IQR&quot;,horiz = TRUE) 8.2.4 Exercicio 1 Obtenha: Analise exploratoria, Analise de variancia, teste de comparação multipla, e recomendações. Comparação de métodos de Semeadura do Mamoeiro Estudo realizado em Jaboticabal - SP por Ruiz (1977) que comparou métodos de semeadura no mamoeiro. O experimento foi instalado em delineamento de blocos casualizados, com 4 repetições, avaliando 3 métodos de semeadura. Foram avaliadas duas unidades experimentais por método em cada bloco. Importando dados dados &lt;- read.table(&quot;https://www.dropbox.com/s/40m95attfw2fdh2/BanzattoQd4.7.1.txt?dl=1&quot;) Conferir se temos fatores para fazer a análise de variância str(dados) ## &#39;data.frame&#39;: 24 obs. of 3 variables: ## $ bloco : Factor w/ 4 levels &quot;I&quot;,&quot;II&quot;,&quot;III&quot;,..: 1 1 2 2 3 3 4 4 1 1 ... ## $ semead: Factor w/ 3 levels &quot;Direta no campo&quot;,..: 1 1 1 1 1 1 1 1 2 2 ... ## $ altura: num 136.1 105.3 98.8 86.8 108.8 ... Gráficos addmargins(with(dados, tapply(X = altura, INDEX = list(semead, bloco), FUN = sum))) ## I II III IV Sum ## Direta no campo 241.4 185.6 218.5 162.9 808.4 ## Recip. ao sol 157.7 120.7 129.0 80.1 487.5 ## Recip. ripado 123.5 127.1 132.9 109.8 493.3 ## Sum 522.6 433.4 480.4 352.8 1789.2 xyplot(altura ~ semead, data = dados, groups = bloco, type = c(&quot;p&quot;, &quot;a&quot;), xlab = &quot;Método de semeadura de mamoeiro&quot;, ylab = &quot;Altura média de planta de mamoeiro aos 147 DAS (cm)&quot;, auto.key = list(title = &quot;Bloco&quot;, cex.title = 1, columns = 2)) Análise de Variância m0 &lt;- aov(altura~bloco+semead, data=dados) class(m0) ## [1] &quot;aov&quot; &quot;lm&quot; anova(m0) ## Analysis of Variance Table ## ## Response: altura ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## bloco 3 2648.2 882.7 7.2162 0.002219 ** ## semead 2 8429.1 4214.6 34.4535 7.014e-07 *** ## Residuals 18 2201.9 122.3 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 summary(m0) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## bloco 3 2648 883 7.216 0.00222 ** ## semead 2 8429 4215 34.453 7.01e-07 *** ## Residuals 18 2202 122 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Checagem gráfica par(mfrow=c(2,2)) plot(m0) layout(1) Teste das pressuposições de normalidade de homocedasticidade shapiro.test(residuals(m0)) ## ## Shapiro-Wilk normality test ## ## data: residuals(m0) ## W = 0.95197, p-value = 0.2988 bartlett.test(residuals(m0)~dados$semead) ## ## Bartlett test of homogeneity of variances ## ## data: residuals(m0) by dados$semead ## Bartlett&#39;s K-squared = 4.5219, df = 2, p-value = 0.1043 Teste de médias Teste de Tukey require(agricolae) tu &lt;- with(dados, HSD.test(altura, semead, DFerror=df.residual(m0), MSerror=deviance(m0)/df.residual(m0))) plot(tu) print(tu) ## $statistics ## MSerror Df Mean CV MSD ## 122.3258 18 74.55 14.83581 14.11359 ## ## $parameters ## test name.t ntr StudentizedRange alpha ## Tukey semead 3 3.609304 0.05 ## ## $means ## altura std r Min Max Q25 Q50 Q75 ## Direta no campo 101.0500 19.263956 8 70.5 136.1 91.000 102.05 109.025 ## Recip. ao sol 60.9375 15.187489 8 36.3 79.8 53.175 63.25 69.650 ## Recip. ripado 61.6625 9.544922 8 43.7 77.1 58.575 62.95 65.425 ## ## $comparison ## NULL ## ## $groups ## altura groups ## Direta no campo 101.0500 a ## Recip. ripado 61.6625 b ## Recip. ao sol 60.9375 b ## ## attr(,&quot;class&quot;) ## [1] &quot;group&quot; require(dplyr) require(ggplot2) erro = summarise(group_by(dados, semead), avg = mean(altura), sd = sd(altura)) ggplot(erro, aes(semead, avg, fill=semead))+ geom_bar(stat=&quot;identity&quot;)+ geom_errorbar(aes(ymin=avg-sd, ymax =avg+sd), with=0.1, col=&quot;black&quot;) + xlab(&quot;Tratamentos&quot;) + ylab(&quot;Altura média de planta de mamoeiro aos 147 DAS (cm)&quot;) + theme_bw() + theme(legend.position=&quot;top&quot;) + annotate(&quot;text&quot;, label=tu$groups$groups[1], x=1, y=20, size = 5) + annotate(&quot;text&quot;, label=tu$groups$groups[2], x=2, y=20, size = 5) + annotate(&quot;text&quot;, label=tu$groups$groups[3], x=3, y=20, size = 5) + theme(legend.position=&quot;none&quot;) + labs(caption = &quot;Médias seguidas de mesma letra indicam diferença nula à 5%&quot;) ## Warning: Ignoring unknown parameters: with Teste de Scott-Knott library(ScottKnott) sk &lt;- SK(x=dados, y=dados$altura, model=&quot;altura~bloco+semead&quot;, which=&quot;semead&quot;) summary(sk) ## Levels Means SK(5%) ## Direta no campo 101.0500 a ## Recip. ripado 61.6625 b ## Recip. ao sol 60.9375 b print(sk) ## $av ## Call: ## aov(formula = altura ~ bloco + semead, data = dat) ## ## Terms: ## bloco semead Residuals ## Sum of Squares 2648.193 8429.103 2201.864 ## Deg. of Freedom 3 2 18 ## ## Residual standard error: 11.0601 ## Estimated effects may be unbalanced ## ## $groups ## [1] 1 2 2 ## ## $nms ## [1] &quot;Direta no campo&quot; &quot;Recip. ao sol&quot; &quot;Recip. ripado&quot; ## ## $ord ## [1] 1 3 2 ## ## $m.inf ## mean min max ## Direta no campo 101.0500 70.5 136.1 ## Recip. ripado 61.6625 43.7 77.1 ## Recip. ao sol 60.9375 36.3 79.8 ## ## $sig.level ## [1] 0.05 ## ## attr(,&quot;class&quot;) ## [1] &quot;SK&quot; &quot;list&quot; 8.2.5 Referência MELO, M. P.; PETERNELI, L. A. Conhecendo o R: Um visão mais que estatística. Viçosa, MG: UFV, 2013. 222p. Cap. 1. BANZATTO, D. A; KRONKA, S. N. Experimentação agrícola. Jaboticabal, SP: FUNEP, 2006, 237p. ZEVIANI, W. M. Estatística Básica e Experimentação no R. 45p. Site: http://www.leg.ufpr.br/~paulojus/ 8.3 Quadrado Latino 8.4 Regressão Linear simples 8.5 Regressão não linear 8.6 Resolução do Livro Banzatto Kronka "],
["acesso-a-bancos-de-dados-climáticos.html", " 9 Acesso a bancos de dados climáticos", " 9 Acesso a bancos de dados climáticos "],
["trabalhando-com-dados-temporais-no-r.html", " 10 Trabalhando com dados temporais no R", " 10 Trabalhando com dados temporais no R "],
["extrair-dados-da-estação-automática-do-inmet.html", " 11 Extrair dados da estação automática do INMET", " 11 Extrair dados da estação automática do INMET "],
["realizando-o-teste-mann-kendall-para-tendência-em-r.html", " 12 Realizando o Teste Mann-Kendall para Tendência em R", " 12 Realizando o Teste Mann-Kendall para Tendência em R "],
["análisando-imagens-de-ensaios-na-agrícultura.html", " 13 Análisando imagens de ensaios na agrícultura 13.1 Classificação de imagens de satélites", " 13 Análisando imagens de ensaios na agrícultura Este capítulo oferece uma introdução ao processamento e classificação de imagens de RPAs no ambiente R, usando algoritmos de aprendizado capazes de realizer diversos processamentos. Ele também fornece um tutorial de referência conciso e prático, que oferece aos leitores uma nosso geral do que é possível realizar no Sistema R com o processamento e classificação de imagens de RPAs. É necessário instalar alguns pacotes necessários para aplicar esta tarefa: install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;filipematias23/FIELDimageR&quot;) install.packages(&quot;sp&quot;) install.packages(&quot;raster&quot;) install.packages(&quot;rgdal&quot;) Carregar os pacote que foram baixados: library(FIELDimageR) library(raster) ## Loading required package: sp ## ## Attaching package: &#39;raster&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## The following objects are masked from &#39;package:MASS&#39;: ## ## area, select Baixar a imagem ortomosaicada: EX1&lt;-stack(&quot;https://www.dropbox.com/s/qxg6fn9ljy35ssm/EX1_RGB.tif?dl=1&quot;) Plotar a imagem nas bandas RGB: plotRGB(EX1, r = 1, g = 2, b = 3) Remover o solo e trabalhar apenas com a vegetação para aplicar os índices de vegetação RGB EX1.RemSoil&lt;- fieldMask(mosaic = EX1, Red = 1, Green = 2, Blue = 3, index = &quot;HUE&quot;) ## [1] &quot;3 layers available&quot; Aplicado os índices de vegetação. Aplicaremos o índice NGRDI, BGI e podemos criar um índice usando as bandas disponíveis. Criaremos como exemplo myIndex com a fórmula Red-Blue/Green EX1.Indices&lt;- indices(mosaic = EX1.RemSoil$newMosaic, Red = 1, Green = 2, Blue = 3, index = c(&quot;NGRDI&quot;,&quot;BGI&quot;), myIndex = c(&quot;(Red-Blue)/Green&quot;)) ## [1] &quot;3 layers available&quot; 13.1 Classificação de imagens de satélites Esse procedimento será realizado com imagens de satélite (Sentinel 2), porêm pode ser aplicado com imagens de RPA, desde que sejam multiespectrais. Carregar pacotes necessários para trabalhar com os dados raster. Caso não tenha algum dos pacotes, realize a sua instalação. library(raster) library(knitr) library(sp) library(rgdal) ## rgdal: version: 1.4-8, (SVN revision 845) ## Geospatial Data Abstraction Library extensions to R successfully loaded ## Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20 ## Path to GDAL shared files: C:/Users/Jefferson/Documents/R/win-library/3.6/rgdal/gdal ## GDAL binary built with GEOS: TRUE ## Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493] ## Path to PROJ.4 shared files: C:/Users/Jefferson/Documents/R/win-library/3.6/rgdal/proj ## Linking to sp version: 1.4-1 library(ggplot2) library(viridis) ## Loading required package: viridisLite library(rasterVis) ## Loading required package: latticeExtra ## ## Attaching package: &#39;latticeExtra&#39; ## The following object is masked from &#39;package:ggplot2&#39;: ## ## layer library(LSRS) Baixar o arquivo . sentinel2.tif. imagesentinel=raster(&#39;sentinel2.tif&#39;) Visualizar os dados imagesentinel ## class : RasterLayer ## band : 1 (of 12 bands) ## dimensions : 507, 848, 429936 (nrow, ncol, ncell) ## resolution : 9.217891e-05, 9.217891e-05 (x, y) ## extent : -4.320218, -4.242051, 56.45366, 56.50039 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : D:/livro/TudodoRa/sentinel2.tif ## names : sentinel2 É necessário criar camadas individuais para cada uma das bandas espectrais: b1 &lt;- raster(&#39;sentinel2.tif&#39;, band=1) b2 &lt;- raster(&#39;sentinel2.tif&#39;, band=2) b3 &lt;- raster(&#39;sentinel2.tif&#39;, band=3) b4 &lt;- raster(&#39;sentinel2.tif&#39;, band=4) b5 &lt;- raster(&#39;sentinel2.tif&#39;, band=5) b6 &lt;- raster(&#39;sentinel2.tif&#39;, band=6) b7 &lt;- raster(&#39;sentinel2.tif&#39;, band=7) b8 &lt;- raster(&#39;sentinel2.tif&#39;, band=8) b9 &lt;- raster(&#39;sentinel2.tif&#39;, band=9) b10 &lt;- raster(&#39;sentinel2.tif&#39;, band=10) b11 &lt;- raster(&#39;sentinel2.tif&#39;, band=11) b12 &lt;- raster(&#39;sentinel2.tif&#39;, band=12) Comparar duas bandas para ver se elas possuem a mesma extensão: compareRaster(b2, b3) ## [1] TRUE Plotar a banda 4 para pré-visualização: plot(b4) image(b4) Visualizar a imagem nas bandas do RGB: RGB &lt;- stack(list(b4, b3, b2)) plotRGB(RGB, axes = TRUE, stretch = &quot;lin&quot;, main = &quot;Sentinel RGB colour composite&quot;) Juntar todas as bandas num só arquivo: t &lt;- stack(b1,b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12) st &lt;- brick(&#39;sentinel2.tif&#39;) plot(st) Aplicar o índice de vegetação NDVI, para o Sentinel 2 com: NIR = 8, red = 4. Criar a VI (vegetation index) por meio de função VI &lt;- function(img, k, i) { bk &lt;- img[[k]] bi &lt;- img[[i]] vi &lt;- (bk - bi) / (bk + bi) return(vi) } NDVI: ndvi &lt;- VI(st, 8, 4) plot(ndvi, col = rev(terrain.colors(10)), main = &quot;Sentinel2-NDVI&quot;) Outras fórmula de aplicar o NDVI vi2 &lt;- function(x, y) { (x - y) / (x + y) } ndvi2 &lt;- overlay(st[[8]], st[[4]], fun=vi2) plot(ndvi2, col=rev(terrain.colors(10)), main=&quot;Sentinel2-NDVI&quot;) Visualizar o NDVI em histograma hist(ndvi, main = &quot;Distribuição dos valores de NDVI&quot;, xlab = &quot;NDVI&quot;, ylab= &quot;Frequência&quot;, col = &quot;wheat&quot;, xlim = c(-0.5, 1), breaks = 30, xaxt = &#39;n&#39;) axis(side=1, at = seq(-0.5,1, 0.05), labels = seq(-0.5,1, 0.05)) Visualizar apenas a vegetação com NDVI acima de 0.4: veg &lt;- reclassify(ndvi, cbind(-Inf, 0.4, NA)) plot(veg, main=&#39;Vegetação&#39;) Reclassificar o NDVI e difini-lo por classes numéricas: vegc &lt;- reclassify(ndvi, c(-Inf,0.25,1, 0.25,0.3,2, 0.3,0.4,3, 0.4,0.5,4, 0.5,Inf, 5)) plot(vegc,col = rev(terrain.colors(4)), main = &#39;NDVI reclassificado&#39;) Criar uma classificação não supervisionada a partir do NDVI: Converter o raster (NDVI) a um vetor/matriz: nr &lt;-getValues(ndvi) str(nr) ## num [1:429936] 0.791 0.791 0.785 0.783 0.783 ... É importante definir o gerador de pontos, porque o “kmeans” inicia os centros em locais aleatórios: set.seed(99) Criar 10 clusters, permitir 500 iterações, comece com 5 conjuntos aleatórios usando o método Lloyd kmncluster &lt;- kmeans(na.omit(nr), centers = 10, iter.max = 500, nstart = 5, algorithm = &quot;Lloyd&quot;) Ver o vetor/matriz: str(kmncluster) ## List of 9 ## $ cluster : int [1:429936] 7 7 7 7 7 7 7 4 4 7 ... ## $ centers : num [1:10, 1] -0.525 0.421 0.846 0.696 0.233 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:10] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. ..$ : NULL ## $ totss : num 156503 ## $ withinss : num [1:10] 67.4 23.6 28.1 28.5 32.4 ... ## $ tot.withinss: num 484 ## $ betweenss : num 156020 ## $ size : int [1:10] 4650 8155 71872 45902 10754 58153 58643 18762 4109 148936 ## $ iter : int 287 ## $ ifault : NULL ## - attr(*, &quot;class&quot;)= chr &quot;kmeans&quot; Crie uma cópia do NDVI para não perder os dados: knr &lt;- ndvi Agora substitua os valores das células de varredura pelo kmncluster$cluster: knr[] &lt;- kmncluster$cluster Realize o plot do NDVI e do kmeans: par(mfrow = c(1, 2)) plot(ndvi, col = rev(terrain.colors(10)), main = &quot;NDVI&quot;) plot(knr, main = &quot;Kmeans&quot;, col = viridis_pal(option = &quot;D&quot;)(10)) Se quiser traçar a classificação kmeans ao lado da renderização do RGB para verificar a qualidade da classificação e identificação das classes: par(mfrow = c(1, 2)) plotRGB(RGB, axes = FALSE, stretch = &quot;lin&quot;, main = &quot;RGB&quot;) plot(knr, main = &quot;Kmeans&quot;, yaxt = &#39;n&#39;, col = viridis_pal(option = &quot;D&quot;)(10)) Aplicar outros índices de vegetação com o pacote LSRS: NDVI=NDVI(b8,b4) SAVI=SAVI(b8,b4) TGSI=TGSI(b4,b2,b3) MSAVI=MSAVI(b8,b4, Pixel.Depth=1) EVI=EVI(b8,b4,b2,Pixel.Depth=1) NBR=NBR(b8,b11) par(mfrow = c(3, 2)) plot(NDVI,lwd=4,main=&quot;NDVI&quot;,xlab=&quot;easting&quot;, ylab=&quot;northing&quot;) plot(SAVI,lwd=4,main=&quot;SAVI&quot;,xlab=&quot;easting&quot;, ylab=&quot;northing&quot;) plot(TGSI,lwd=4,main=&quot;TGSI&quot;,xlab=&quot;easting&quot;, ylab=&quot;northing&quot;) plot(MSAVI,lwd=4,main=&quot;MSAVI&quot;,xlab=&quot;easting&quot;, ylab=&quot;northing&quot;) plot(EVI,lwd=4,main=&quot;EVI&quot;,xlab=&quot;easting&quot;, ylab=&quot;northing&quot;) plot(NBR,lwd=4,main=&quot;NBR&quot;,xlab=&quot;easting&quot;, ylab=&quot;northing&quot;) "],
["references.html", "References", " References "]
]
